!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/darren@hiebert.com/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.0.1	//
ALIAS	defines.h	165;"	d
ALIAS_HASHTABLE_SIZE	defines.h	41;"	d
BEGIN	lex.yy.c	79;"	d	file:
BODY_READ	defines.h	147;"	d
BODY_WRITE	defines.h	148;"	d
BUFFER_SIZE	defines.h	38;"	d
CC	Makefile	/^CC = gcc $/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -O2 -Wall -I.$/;"	m
CGI	defines.h	160;"	d
CGI_ARGC_MAX	defines.h	71;"	d
CGI_BUFFER	defines.h	179;"	d
CGI_DONE	defines.h	180;"	d
CGI_ENV_MAX	defines.h	70;"	d
CGI_MIME_TYPE	defines.h	46;"	d
CGI_PARSE	defines.h	178;"	d
CGI_VERSION	defines.h	68;"	d
CLIENT_READABLE	defines.h	156;"	d
CLIENT_STREAM_SIZE	defines.h	37;"	d
CLIENT_WRITABLE	defines.h	155;"	d
COMMON_CGI_COUNT	defines.h	69;"	d
CONST	index_dir.c	44;"	d	file:
CONST	index_dir.c	46;"	d	file:
CPP	Makefile	/^CPP = gcc -E$/;"	m
DBG	config.c	37;"	d	file:
DBG	config.c	39;"	d	file:
DBG	y.tab.c	51;"	d	file:
DBG	y.tab.c	53;"	d	file:
DEAD	defines.h	153;"	d
DEFAULT_PATH	defines.h	47;"	d
DIR	Makefile	/^DIR = \/doc\/$/;"	m
DONE	defines.h	152;"	d
ECHO	Makefile	/^ECHO = \/bin\/echo$/;"	m
ECHO	lex.yy.c	540;"	d	file:
EOB_ACT_CONTINUE_SCAN	lex.yy.c	104;"	d	file:
EOB_ACT_END_OF_FILE	lex.yy.c	105;"	d	file:
EOB_ACT_LAST_MATCH	lex.yy.c	106;"	d	file:
FLEX_SCANNER	lex.yy.c	7;"	d	file:
GCC_FLAGS	Makefile	/^GCC_FLAGS = -Wstrict-prototypes -Wpointer-arith -Wcast-align -Wcast-qual\\$/;"	m
GETPWUID	defines.h	136;"	d
GUNZIP	acconfig.h	1;"	d
GUNZIP	config.h	36;"	d
GZ	Makefile	/^GZ = \/test_file$/;"	m
HAVE_DIRENT_H	config.h	62;"	d
HAVE_FCNTL_H	config.h	65;"	d
HAVE_GETCWD	config.h	41;"	d
HAVE_GETHOSTNAME	config.h	44;"	d
HAVE_GETPAGESIZE	config.h	47;"	d
HAVE_LIMITS_H	config.h	68;"	d
HAVE_MMAP	config.h	11;"	d
HAVE_SELECT	config.h	50;"	d
HAVE_SOCKET	config.h	53;"	d
HAVE_STRDUP	config.h	56;"	d
HAVE_STRSTR	config.h	59;"	d
HAVE_SYS_SELECT_H	config.h	80;"	d
HAVE_SYS_TIME_H	config.h	83;"	d
HAVE_SYS_WAIT_H	config.h	14;"	d
HAVE_UNISTD_H	config.h	86;"	d
HEX	request.c	99;"	d	file:
HEX_TO_DECIMAL	util.c	28;"	d	file:
HTML	response.c	27;"	d	file:
INITGROUPS	defines.h	137;"	d
INITIAL	lex.yy.c	410;"	d	file:
INTEGER	y.tab.c	12;"	d	file:
INTEGER	y.tab.h	11;"	d
INT_TO_HEX	buffer.c	27;"	d	file:
INT_TO_HEX	index_dir.c	34;"	d	file:
KA_ACTIVE	defines.h	173;"	d
KA_INACTIVE	defines.h	171;"	d
KA_STOPPED	defines.h	172;"	d
LDFLAGS	Makefile	/^LDFLAGS = $/;"	m
LEX	Makefile	/^LEX = flex $/;"	m
LIBS	Makefile	/^LIBS = $/;"	m
MAP_OPTIONS	compat.h	65;"	d
MAP_OPTIONS	compat.h	67;"	d
MAX_ACCEPT_LENGTH	defines.h	59;"	d
MAX_ACCEPT_LENGTH	defines.h	61;"	d
MAX_FILE_LENGTH	defines.h	55;"	d
MAX_FILE_LENGTH	index_dir.c	31;"	d	file:
MAX_FILE_MMAP	defines.h	189;"	d
MAX_HASH_LENGTH	hash.c	88;"	d	file:
MAX_HEADER_LENGTH	defines.h	36;"	d
MAX_LOG_LENGTH	defines.h	54;"	d
MAX_PATH_LENGTH	defines.h	56;"	d
MAX_PATH_LENGTH	index_dir.c	32;"	d	file:
MAX_SITENAME_LENGTH	defines.h	53;"	d
MAX_STR_CONST	lex.yy.c	440;"	d	file:
MIME	lex.yy.c	454;"	d	file:
MIMETYPE	y.tab.c	10;"	d	file:
MIMETYPE	y.tab.h	9;"	d
MIME_HASHTABLE_SIZE	defines.h	40;"	d
MMAP_LIST_HASH	defines.h	187;"	d
MMAP_LIST_MASK	defines.h	184;"	d
MMAP_LIST_NEXT	defines.h	186;"	d
MMAP_LIST_SIZE	defines.h	183;"	d
MMAP_LIST_USE_MAX	defines.h	185;"	d
M_DELETE	defines.h	119;"	d
M_GET	defines.h	115;"	d
M_HEAD	defines.h	116;"	d
M_LINK	defines.h	120;"	d
M_POST	defines.h	118;"	d
M_PUT	defines.h	117;"	d
M_UNLINK	defines.h	121;"	d
NAMLEN	compat.h	82;"	d
NAMLEN	compat.h	85;"	d
NEEDS_ESCAPE_BITS	escape.h	28;"	d
NEEDS_ESCAPE_INDEX	escape.h	36;"	d
NEEDS_ESCAPE_MASK	escape.h	39;"	d
NEEDS_ESCAPE_SHIFT	acconfig.h	3;"	d
NEEDS_ESCAPE_SHIFT	config.h	38;"	d
NEEDS_ESCAPE_SHIFT	escape.h	31;"	d
NEEDS_ESCAPE_WORD_LENGTH	escape.h	34;"	d
NI_MAXHOST	compat.h	46;"	d
NOBLOCK	compat.h	59;"	d
NOBLOCK	compat.h	61;"	d
NORMAL	Makefile	/^NORMAL = \/test_file.gz$/;"	m
NO_BIND	defines.h	130;"	d
NO_CREATE_SOCKET	defines.h	127;"	d
NO_FCNTL	defines.h	128;"	d
NO_LISTEN	defines.h	131;"	d
NO_OPEN_LOG	defines.h	134;"	d
NO_SETGID	defines.h	132;"	d
NO_SETSOCKOPT	defines.h	129;"	d
NO_SETUID	defines.h	133;"	d
NPH	defines.h	161;"	d
OBJS	Makefile	/^OBJS = y.tab.o lex.yy.o ${SOURCES:.c=.o} timestamp.o$/;"	m
ONE_CR	defines.h	144;"	d
ONE_LF	defines.h	145;"	d
OPEN_MAX	compat.h	42;"	d
OUT_OF_MEMORY	defines.h	126;"	d
PASSWD_HASHTABLE_SIZE	defines.h	42;"	d
PATH_MAX	compat.h	54;"	d
PIPE_READ	defines.h	150;"	d
PIPE_WRITE	defines.h	151;"	d
READ_HEADER	defines.h	143;"	d
REDIRECT	defines.h	167;"	d
REJECT	lex.yy.c	404;"	d	file:
REQUEST_TIMEOUT	defines.h	44;"	d
R_ACCEPTED	defines.h	85;"	d
R_BAD_GATEWAY	defines.h	108;"	d
R_BAD_REQUEST	defines.h	94;"	d
R_BAD_VERSION	defines.h	111;"	d
R_CLIENT_ERROR	defines.h	78;"	d
R_CONFLICT	defines.h	103;"	d
R_CREATED	defines.h	84;"	d
R_ERROR	defines.h	106;"	d
R_FORBIDDEN	defines.h	97;"	d
R_GATEWAY_TO	defines.h	110;"	d
R_GONE	defines.h	104;"	d
R_INFORMATIONAL	defines.h	75;"	d
R_METHOD_NA	defines.h	99;"	d
R_MOVED_PERM	defines.h	90;"	d
R_MOVED_TEMP	defines.h	91;"	d
R_MULTIPLE	defines.h	89;"	d
R_NONE_ACC	defines.h	100;"	d
R_NOT_FOUND	defines.h	98;"	d
R_NOT_IMP	defines.h	107;"	d
R_NOT_MODIFIED	defines.h	92;"	d
R_NO_CONTENT	defines.h	87;"	d
R_PAYMENT	defines.h	96;"	d
R_PROVISIONAL	defines.h	86;"	d
R_PROXY	defines.h	101;"	d
R_REDIRECTION	defines.h	77;"	d
R_REQUEST_OK	defines.h	83;"	d
R_REQUEST_TO	defines.h	102;"	d
R_SERVER_ERROR	defines.h	79;"	d
R_SERVICE_UNAV	defines.h	109;"	d
R_SUCCESS	defines.h	76;"	d
R_UNAUTHORIZED	defines.h	95;"	d
S0A	config.c	94;"	d	file:
S1A	config.c	95;"	d	file:
S2A	config.c	96;"	d	file:
SCRIPTALIAS	defines.h	166;"	d
SELECT	defines.h	135;"	d
SERVER_AF	compat.h	73;"	d
SERVER_AF	compat.h	77;"	d
SERVER_ERROR	defines.h	125;"	d
SERVER_ROOT	defines.h	30;"	d
SERVER_VERSION	defines.h	65;"	d
SHUTDOWN	defines.h	139;"	d
SOCKADDR	compat.h	71;"	d
SOCKADDR	compat.h	75;"	d
SOCKET	Makefile	/^SOCKET = socket localhost 80$/;"	m
SOCKETBUF_SIZE	defines.h	35;"	d
SOURCES	Makefile	/^SOURCES = alias.c boa.c buffer.c cgi.c cgi_header.c config.c escape.c \\$/;"	m
SO_MAXCONN	compat.h	50;"	d
SQUASH_KA	defines.h	175;"	d
STDC_HEADERS	config.h	25;"	d
STMT_NO_ARGS	y.tab.c	7;"	d	file:
STMT_NO_ARGS	y.tab.h	6;"	d
STMT_ONE_ARG	y.tab.c	8;"	d	file:
STMT_ONE_ARG	y.tab.h	7;"	d
STMT_TWO_ARGS	y.tab.c	9;"	d	file:
STMT_TWO_ARGS	y.tab.h	8;"	d
STRING	y.tab.c	11;"	d	file:
STRING	y.tab.h	10;"	d
S_FAMILY	compat.h	72;"	d
S_FAMILY	compat.h	76;"	d
TIME_WITH_SYS_TIME	config.h	28;"	d
TWO_CR	defines.h	146;"	d
WRITE	defines.h	149;"	d
YACC	Makefile	/^YACC = bison -y $/;"	m
YYABORT	y.tab.c	276;"	d	file:
YYACCEPT	y.tab.c	275;"	d	file:
YYBACKUP	y.tab.c	284;"	d	file:
YYBISON	y.tab.c	5;"	d	file:
YYEMPTY	y.tab.c	273;"	d	file:
YYEOF	y.tab.c	274;"	d	file:
YYERRCODE	y.tab.c	297;"	d	file:
YYERROR	y.tab.c	277;"	d	file:
YYFAIL	y.tab.c	282;"	d	file:
YYFINAL	y.tab.c	76;"	d	file:
YYFLAG	y.tab.c	77;"	d	file:
YYINITDEPTH	y.tab.c	344;"	d	file:
YYLAST	y.tab.c	177;"	d	file:
YYLEX	y.tab.c	300;"	d	file:
YYLEX	y.tab.c	306;"	d	file:
YYLEX	y.tab.c	308;"	d	file:
YYLEX	y.tab.c	312;"	d	file:
YYLEX	y.tab.c	314;"	d	file:
YYMAXDEPTH	y.tab.c	351;"	d	file:
YYMAXDEPTH	y.tab.c	355;"	d	file:
YYNTBASE	y.tab.c	78;"	d	file:
YYPARSE_PARAM_ARG	y.tab.c	412;"	d	file:
YYPARSE_PARAM_ARG	y.tab.c	415;"	d	file:
YYPARSE_PARAM_ARG	y.tab.c	419;"	d	file:
YYPARSE_PARAM_DECL	y.tab.c	413;"	d	file:
YYPARSE_PARAM_DECL	y.tab.c	416;"	d	file:
YYPARSE_PARAM_DECL	y.tab.c	420;"	d	file:
YYPOPSTACK	y.tab.c	454;"	d	file:
YYPOPSTACK	y.tab.c	456;"	d	file:
YYRECOVERING	y.tab.c	283;"	d	file:
YYSTACK_ALLOC	y.tab.c	262;"	d	file:
YYSTACK_ALLOC	y.tab.c	264;"	d	file:
YYSTACK_USE_ALLOCA	y.tab.c	221;"	d	file:
YYSTACK_USE_ALLOCA	y.tab.c	224;"	d	file:
YYSTACK_USE_ALLOCA	y.tab.c	228;"	d	file:
YYSTACK_USE_ALLOCA	y.tab.c	245;"	d	file:
YYSTACK_USE_ALLOCA	y.tab.c	250;"	d	file:
YYSTATE	lex.yy.c	86;"	d	file:
YYSTYPE	y.tab.c	/^} YYSTYPE;$/;"	t	file:
YYSTYPE	y.tab.h	/^} YYSTYPE;$/;"	t
YYTERROR	y.tab.c	296;"	d	file:
YYTRANSLATE	y.tab.c	80;"	d	file:
YY_AT_BOL	lex.yy.c	262;"	d	file:
YY_BREAK	lex.yy.c	599;"	d	file:
YY_BUFFER_EOF_PENDING	lex.yy.c	198;"	d	file:
YY_BUFFER_NEW	lex.yy.c	186;"	d	file:
YY_BUFFER_NORMAL	lex.yy.c	187;"	d	file:
YY_BUFFER_STATE	lex.yy.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	file:
YY_BUF_SIZE	lex.yy.c	97;"	d	file:
YY_CHAR	lex.yy.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	lex.yy.c	207;"	d	file:
YY_DECL	lex.yy.c	587;"	d	file:
YY_DO_BEFORE_ACTION	lex.yy.c	278;"	d	file:
YY_END_OF_BUFFER	lex.yy.c	286;"	d	file:
YY_END_OF_BUFFER_CHAR	lex.yy.c	94;"	d	file:
YY_EXIT_FAILURE	lex.yy.c	1598;"	d	file:
YY_FATAL_ERROR	lex.yy.c	580;"	d	file:
YY_FLEX_MAJOR_VERSION	lex.yy.c	8;"	d	file:
YY_FLEX_MINOR_VERSION	lex.yy.c	9;"	d	file:
YY_FLUSH_BUFFER	lex.yy.c	236;"	d	file:
YY_INPUT	lex.yy.c	547;"	d	file:
YY_MORE_ADJ	lex.yy.c	406;"	d	file:
YY_NEW_FILE	lex.yy.c	92;"	d	file:
YY_NO_POP_STATE	lex.yy.c	510;"	d	file:
YY_NO_PUSH_STATE	lex.yy.c	509;"	d	file:
YY_NO_TOP_STATE	lex.yy.c	511;"	d	file:
YY_NULL	lex.yy.c	66;"	d	file:
YY_NUM_RULES	lex.yy.c	285;"	d	file:
YY_PROTO	lex.yy.c	60;"	d	file:
YY_PROTO	lex.yy.c	62;"	d	file:
YY_READ_BUF_SIZE	lex.yy.c	531;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	lex.yy.c	407;"	d	file:
YY_RULE_SETUP	lex.yy.c	602;"	d	file:
YY_SC_TO_UI	lex.yy.c	73;"	d	file:
YY_START	lex.yy.c	85;"	d	file:
YY_START_STACK_INCR	lex.yy.c	575;"	d	file:
YY_STATE_EOF	lex.yy.c	89;"	d	file:
YY_USER_ACTION	lex.yy.c	594;"	d	file:
YY_USE_CONST	lex.yy.c	31;"	d	file:
YY_USE_CONST	lex.yy.c	38;"	d	file:
YY_USE_CONST	lex.yy.c	48;"	d	file:
YY_USE_PROTOS	lex.yy.c	28;"	d	file:
YY_USE_PROTOS	lex.yy.c	37;"	d	file:
YY_USE_PROTOS	lex.yy.c	49;"	d	file:
_BOA_H	boa.h	26;"	d
_COMPAT_H	compat.h	24;"	d
_DEFINES_H	defines.h	25;"	d
_GLOBALS_H	globals.h	26;"	d
__cplusplus	lex.yy.c	18;"	d	file:
__yy_memcpy	y.tab.c	/^__yy_memcpy (char *to, char *from, unsigned int count)$/;"	f	file:
__yy_memcpy	y.tab.c	/^__yy_memcpy (to, from, count)$/;"	f	file:
__yy_memcpy	y.tab.c	364;"	d	file:
_hash_struct_	hash.c	/^struct _hash_struct_ {$/;"	s	file:
_needs_escape	escape.c	/^unsigned long _needs_escape[(NEEDS_ESCAPE_BITS+NEEDS_ESCAPE_WORD_LENGTH-1)\/NEEDS_ESCAPE_WORD_LENGTH];$/;"	v
accept	globals.h	/^    char accept[MAX_ACCEPT_LENGTH]; \/* Accept: fields *\/$/;"	m	struct:request
access_log	log.c	/^FILE *access_log;$/;"	v
access_log_name	config.c	/^char *access_log_name;$/;"	v
access_log_name	log.c	/^char *access_log_name;$/;"	v
action	parse.h	/^    void (*action) (char *, char *, void *);$/;"	m	struct:ccommand
add_accept_header	request.c	/^void add_accept_header(request * req, char *mime_type)$/;"	f
add_alias	alias.c	/^void add_alias(char *fakename, char *realname, int type)$/;"	f
add_cgi_env	cgi.c	/^void add_cgi_env(request * req, char *key, char *value)$/;"	f
add_mime_type	hash.c	/^void add_mime_type(char *extension, char *type)$/;"	f
alias	globals.h	/^struct alias {$/;"	s
alias	globals.h	/^typedef struct alias alias;$/;"	t
alias_hashtable	alias.c	/^static alias *alias_hashtable[ALIAS_HASHTABLE_SIZE];$/;"	v	file:
alias_number	config.c	/^int alias_number = ALIAS;$/;"	v
alloca	y.tab.c	225;"	d	file:
alloca	y.tab.c	251;"	d	file:
arg1hold	y.tab.c	/^char *arg1hold;$/;"	v
ascii_sockaddr	ip.c	/^char *ascii_sockaddr(struct SOCKADDR *s, char *dest, int len)$/;"	f
backlog	boa.c	/^int backlog = SO_MAXCONN;$/;"	v
bind_server	ip.c	/^int bind_server(int server_s, char *server_ip)$/;"	f
block_read_fdset	boa.c	/^fd_set block_read_fdset;$/;"	v
block_request	queue.c	/^void block_request(request * req)$/;"	f
block_write_fdset	boa.c	/^fd_set block_write_fdset;$/;"	v
boa_hash	hash.c	55;"	d	file:
boa_hash	hash.c	59;"	d	file:
boa_hash	hash.c	62;"	d	file:
boa_perror	log.c	/^void boa_perror(request * req, char *message)$/;"	f
buffer	globals.h	/^    char buffer[BUFFER_SIZE + 1]; \/* generic I\/O buffer *\/$/;"	m	struct:request
buffer_end	globals.h	/^    int buffer_end;             \/* where the buffer ends *\/$/;"	m	struct:request
buffer_start	globals.h	/^    int buffer_start;           \/* where the buffer starts *\/$/;"	m	struct:request
build_needs_escape	escape.c	/^void build_needs_escape(void)$/;"	f
c_add_alias	config.c	/^void c_add_alias(char *v1, char *v2, void *t)$/;"	f
c_add_type	config.c	/^void c_add_type(char *v1, char *v2, void *t)$/;"	f
c_set_group	config.c	/^void c_set_group(char *v1, char *v2, void *t)$/;"	f
c_set_int	config.c	/^void c_set_int(char *v1, char *v2, void *t)$/;"	f
c_set_string	config.c	/^void c_set_string(char *v1, char *v2, void *t)$/;"	f
c_set_unity	config.c	/^void c_set_unity(char *v1, char *v2, void *t)$/;"	f
c_set_user	config.c	/^void c_set_user(char *v1, char *v2, void *t)$/;"	f
cachedir	config.c	/^char *cachedir;$/;"	v
ccommand	parse.h	/^struct ccommand {$/;"	s
cgi_env	globals.h	/^    char **cgi_env;             \/* CGI environment *\/$/;"	m	struct:request
cgi_env_index	globals.h	/^    int cgi_env_index;          \/* index into array *\/$/;"	m	struct:request
cgi_log_fd	log.c	/^int cgi_log_fd;$/;"	v
cgi_log_name	config.c	/^char *cgi_log_name;$/;"	v
cgi_log_name	log.c	/^char *cgi_log_name;$/;"	v
cgi_status	globals.h	/^    int cgi_status;$/;"	m	struct:request
chroot_path	config.c	/^char *chroot_path;$/;"	v
clean_pathname	util.c	/^void clean_pathname(char *pathname)$/;"	f
client_stream	globals.h	/^    char client_stream[CLIENT_STREAM_SIZE]; \/* data from client - fit or be hosed *\/$/;"	m	struct:request
client_stream_pos	globals.h	/^    int client_stream_pos;      \/* how much have we read... *\/$/;"	m	struct:request
clist	config.c	/^struct ccommand clist[] = {$/;"	v
close_access_log	log.c	/^void close_access_log(void)$/;"	f
common_cgi_env	cgi.c	/^static char **common_cgi_env;$/;"	v	file:
complete_env	cgi.c	/^void complete_env(request * req)$/;"	f
const	y.tab.c	70;"	d	file:
content_length	globals.h	/^    char *content_length;       \/* env variable *\/$/;"	m	struct:request
content_type	globals.h	/^    char *content_type;         \/* env variable *\/$/;"	m	struct:request
create_argv	cgi.c	/^void create_argv(request * req, char **aargv)$/;"	f
create_common_env	cgi.c	/^void create_common_env()$/;"	f
create_env	cgi.c	/^void create_env(request * req)$/;"	f
current_time	boa.c	/^time_t current_time;$/;"	v
cval	y.tab.c	/^    struct ccommand * cval;$/;"	m	union:	file:
cval	y.tab.h	/^    struct ccommand * cval;$/;"	m	union:
data_fd	globals.h	/^    int data_fd;                \/* fd of data *\/$/;"	m	struct:request
data_mem	globals.h	/^    char *data_mem;             \/* mmapped\/malloced char array *\/$/;"	m	struct:request
day_tab	util.c	/^const char day_tab[] = "Sun,Mon,Tue,Wed,Thu,Fri,Sat,";$/;"	v
default_type	config.c	/^char *default_type;$/;"	v
dequeue	queue.c	/^void dequeue(request ** head, request * req)$/;"	f
dev	globals.h	/^    dev_t dev;$/;"	m	struct:mmap_entry
directory_index	config.c	/^char *directory_index;$/;"	v
dirent	compat.h	84;"	d
dirmaker	config.c	/^char *dirmaker;$/;"	v
djb2_hash	hash.c	/^static unsigned djb2_hash(char *str)$/;"	f	file:
do_fork	boa.c	/^int do_fork = 1;$/;"	v
document_root	config.c	/^char *document_root;$/;"	v
dump_alias	alias.c	/^void dump_alias(void)$/;"	f
dump_mime	hash.c	/^void dump_mime(void)$/;"	f
dump_passwd	hash.c	/^void dump_passwd(void)$/;"	f
enqueue	queue.c	/^void enqueue(request ** head, request * req)$/;"	f
env_gen	boa.h	137;"	d
env_gen_extra	cgi.c	/^char *env_gen_extra(const char *key, const char *value, int extra)$/;"	f
error_log_name	config.c	/^char *error_log_name;$/;"	v
error_log_name	log.c	/^char *error_log_name;$/;"	v
errors	globals.h	/^    long errors;$/;"	m	struct:status
escape_string	buffer.c	/^char *escape_string(char *inp, char *buf)$/;"	f
fake_len	globals.h	/^    int fake_len;               \/* strlen of fakename *\/$/;"	m	struct:alias
fakename	globals.h	/^    char *fakename;             \/* URI path to file *\/$/;"	m	struct:alias
fd	globals.h	/^    int fd;                     \/* client's socket fd *\/$/;"	m	struct:request
fdset_update	boa.c	/^inline void fdset_update(void)$/;"	f
file	lex.yy.c	/^static int file = 0;$/;"	v	file:
filepos	globals.h	/^    unsigned long filepos;      \/* position in file *\/$/;"	m	struct:request
filesize	globals.h	/^    unsigned long filesize;     \/* filesize *\/$/;"	m	struct:request
find_alias	alias.c	/^alias *find_alias(char *uri)$/;"	f
find_mmap	mmap_cache.c	/^struct mmap_entry *find_mmap(int data_fd, struct stat *s)$/;"	f
find_named_mmap	mmap_cache.c	/^struct mmap_entry *find_named_mmap(char *fname)$/;"	f
fixup_server_root	boa.c	/^void fixup_server_root()$/;"	f
fopen_gen_fd	log.c	/^FILE *fopen_gen_fd(char *spec, const char *mode)$/;"	f
four_char_hash	hash.c	/^static unsigned four_char_hash(char *buf)$/;"	f	file:
free_request	request.c	/^static void free_request(request ** list_head_addr, request * req)$/;"	f	file:
free_requests	request.c	/^void free_requests(void)$/;"	f
get_alias_hash_value	alias.c	/^inline int get_alias_hash_value(char *file)$/;"	f
get_buffer_len	response.c	149;"	d	file:
get_cachedir_file	get.c	/^int get_cachedir_file(request * req, struct stat *statbuf)$/;"	f
get_commonlog_time	util.c	/^char *get_commonlog_time(void)$/;"	f
get_dir	get.c	/^int get_dir(request * req, struct stat *statbuf)$/;"	f
get_home_dir	hash.c	/^char *get_home_dir(char *name)$/;"	f
get_homedir_hash_value	hash.c	/^unsigned get_homedir_hash_value(char *name)$/;"	f
get_mime_hash_value	hash.c	/^unsigned get_mime_hash_value(char *extension)$/;"	f
get_mime_type	hash.c	/^char *get_mime_type(char *filename)$/;"	f
get_request	request.c	/^void get_request(int server_s)$/;"	f
hash_struct	hash.c	/^typedef struct _hash_struct_ hash_struct;$/;"	t	file:
header_end	globals.h	/^    char *header_end;           \/* last known end of header, or end of processed data *\/$/;"	m	struct:request
header_line	globals.h	/^    char *header_line;          \/* beginning of un or incompletely processed header line *\/$/;"	m	struct:request
header_referer	globals.h	/^    char *header_referer;$/;"	m	struct:request
header_user_agent	globals.h	/^    char *header_user_agent;$/;"	m	struct:request
html_escape_string	index_dir.c	/^char *html_escape_string(char *inp, char *dest, const int len)$/;"	f
http_escape_string	index_dir.c	/^char *http_escape_string(char *inp, char *buf, const int len)$/;"	f
http_version	globals.h	/^    char *http_version;         \/* HTTP\/?.? of req *\/$/;"	m	struct:request
if_modified_since	globals.h	/^    char *if_modified_since;    \/* If-Modified-Since *\/$/;"	m	struct:request
index_directory	get.c	/^int index_directory(request * req, char *dest_filename)$/;"	f
index_directory	index_dir.c	/^int index_directory(char *dir, char *title)$/;"	f
init_cgi	cgi.c	/^int init_cgi(request * req)$/;"	f
init_get	get.c	/^int init_get(request * req)$/;"	f
init_script_alias	alias.c	/^int init_script_alias(request * req, alias * current1, int uri_len)$/;"	f
init_signals	signals.c	/^void init_signals(void)$/;"	f
ino	globals.h	/^    ino_t ino;$/;"	m	struct:mmap_entry
is_cgi	globals.h	/^    int is_cgi;                 \/* true if CGI\/NPH *\/$/;"	m	struct:request
ival	y.tab.c	/^    int		ival;$/;"	m	union:	file:
ival	y.tab.h	/^    int		ival;$/;"	m	union:
k	lex.yy.c	/^struct ccommand *k; $/;"	v
ka_max	config.c	/^int ka_max;$/;"	v
ka_timeout	config.c	/^int ka_timeout;$/;"	v
kacount	globals.h	/^    int kacount;                \/* keepalive count *\/$/;"	m	struct:request
keepalive	globals.h	/^    int keepalive;              \/* keepalive status *\/$/;"	m	struct:request
key	hash.c	/^    char *key;$/;"	m	struct:_hash_struct_	file:
lame_duck_mode	boa.c	/^short lame_duck_mode = 0;$/;"	v
lame_duck_mode_run	signals.c	/^void lame_duck_mode_run(int server_s)$/;"	f
last_modified	globals.h	/^    time_t last_modified;       \/* Last-modified: *\/$/;"	m	struct:request
len	globals.h	/^    size_t len;$/;"	m	struct:mmap_entry
lineno	lex.yy.c	/^int lineno = 1;$/;"	v
local_ip_addr	globals.h	/^    char local_ip_addr[NI_MAXHOST]; \/* for virtualhost *\/$/;"	m	struct:request
log_access	log.c	/^void log_access(request * req)$/;"	f
log_error_doc	log.c	/^void log_error_doc(request * req)$/;"	f
log_error_mesg	log.c	/^void log_error_mesg(char *file, int line, char *mesg)$/;"	f
log_error_time	log.c	/^void log_error_time()$/;"	f
logline	globals.h	/^    char *logline;              \/* line to log file *\/$/;"	m	struct:request
lookup_keyword	config.c	/^struct ccommand *lookup_keyword(char *c)$/;"	f
main	boa.c	/^int main(int argc, char **argv)$/;"	f
main	escape.c	/^int main(void)$/;"	f
main	index_dir.c	/^int main(int argc, char *argv[])$/;"	f
main	lex.yy.c	/^int main()$/;"	f
main	sublog.c	/^int main(int argc, char *argv[])$/;"	f
max_connections	boa.c	/^int max_connections = 0;$/;"	v
method	globals.h	/^    int method;                 \/* M_GET, M_POST, etc. *\/$/;"	m	struct:request
mime_hashtable	hash.c	/^static hash_struct *mime_hashtable[MIME_HASHTABLE_SIZE];$/;"	v	file:
mime_type	y.tab.c	/^char mime_type[256];            \/* global to inherit *\/$/;"	v
mime_types	lex.yy.c	/^char *mime_types = NULL;$/;"	v
mmap	globals.h	/^    char *mmap;$/;"	m	struct:mmap_entry
mmap_entry	globals.h	/^struct mmap_entry {$/;"	s
mmap_entry_var	globals.h	/^    struct mmap_entry *mmap_entry_var;$/;"	m	struct:request
mmap_list	globals.h	/^struct mmap_entry mmap_list[MMAP_LIST_SIZE];$/;"	v
mmap_list_entries_used	mmap_cache.c	/^int mmap_list_entries_used = 0;$/;"	v
mmap_list_hash_bounces	mmap_cache.c	/^int mmap_list_hash_bounces = 0;$/;"	v
mmap_list_total_requests	mmap_cache.c	/^int mmap_list_total_requests = 0;$/;"	v
modified_since	util.c	/^int modified_since(time_t * mtime, char *if_modified_since)$/;"	f
month2int	util.c	/^int month2int(char *monthname)$/;"	f
month_tab	util.c	/^const char month_tab[48] =$/;"	v
name	parse.h	/^    char *name;$/;"	m	struct:ccommand
needs_escape	escape.h	44;"	d
net_port	ip.c	/^int net_port(struct SOCKADDR *s)$/;"	f
new_request	request.c	/^request *new_request(void)$/;"	f
next	globals.h	/^    struct alias *next;$/;"	m	struct:alias
next	globals.h	/^    struct request *next;       \/* next *\/$/;"	m	struct:request
next	hash.c	/^    struct _hash_struct_ *next;$/;"	m	struct:_hash_struct_	file:
object	parse.h	/^    void *object;$/;"	m	struct:ccommand
open_gen_fd	sublog.c	/^int open_gen_fd(char *spec)$/;"	f
open_logs	log.c	/^void open_logs(void)$/;"	f
open_net_fd	sublog.c	/^int open_net_fd(char *spec)$/;"	f
open_pipe_fd	sublog.c	/^int open_pipe_fd(char *command)$/;"	f
opendir	configure	/^opendir()$/;"	f
parse_pos	globals.h	/^    int parse_pos;              \/* how much have we parsed *\/$/;"	m	struct:request
passwd_hashtable	hash.c	/^static hash_struct *passwd_hashtable[PASSWD_HASHTABLE_SIZE];$/;"	v	file:
path_info	globals.h	/^    char *path_info;            \/* env variable *\/$/;"	m	struct:request
path_translated	globals.h	/^    char *path_translated;      \/* env variable *\/$/;"	m	struct:request
pathname	globals.h	/^    char *pathname;             \/* pathname of requested file *\/$/;"	m	struct:request
pidfile	config.c	/^char *pidfile;$/;"	v
post_data_fd	globals.h	/^    int post_data_fd;           \/* fd for post data tmpfile *\/$/;"	m	struct:request
prev	globals.h	/^    struct request *prev;       \/* previous *\/$/;"	m	struct:request
print_content_length	response.c	/^void print_content_length(request * req)$/;"	f
print_content_type	response.c	/^void print_content_type(request * req)$/;"	f
print_http_headers	response.c	/^void print_http_headers(request * req)$/;"	f
print_ka_phrase	response.c	/^inline void print_ka_phrase(request * req)$/;"	f
print_last_modified	response.c	/^inline void print_last_modified(request * req)$/;"	f
process_cgi_header	cgi_header.c	/^int process_cgi_header(request * req)$/;"	f
process_get	get.c	/^int process_get(request * req)$/;"	f
process_header_end	request.c	/^int process_header_end(request * req)$/;"	f
process_logline	request.c	/^int process_logline(request * req)$/;"	f
process_option_line	request.c	/^void process_option_line(request * req)$/;"	f
process_requests	request.c	/^void process_requests(void)$/;"	f
qspush	lex.yy.c	441;"	d	file:
query_string	globals.h	/^    char *query_string;         \/* env variable *\/$/;"	m	struct:request
read_body	read.c	/^int read_body(request * req)$/;"	f
read_config_files	config.c	/^void read_config_files(void)$/;"	f
read_from_pipe	pipe.c	/^int read_from_pipe(request * req)$/;"	f
read_header	read.c	/^int read_header(request * req)$/;"	f
ready_request	queue.c	/^void ready_request(request * req)$/;"	f
real_len	globals.h	/^    int real_len;               \/* strlen of realname *\/$/;"	m	struct:alias
realname	globals.h	/^    char *realname;             \/* Actual path to file *\/$/;"	m	struct:alias
redirect_number	config.c	/^int redirect_number = REDIRECT;$/;"	v
release_mmap	mmap_cache.c	/^void release_mmap(struct mmap_entry *e)$/;"	f
remote_ip_addr	globals.h	/^    char remote_ip_addr[NI_MAXHOST]; \/* after inet_ntoa *\/$/;"	m	struct:request
remote_port	globals.h	/^    int remote_port;            \/* could be used for ident *\/$/;"	m	struct:request
req_flush	buffer.c	/^int req_flush(request * req)$/;"	f
req_timeout	boa.c	/^struct timeval req_timeout;     \/* timeval for select *\/$/;"	v
req_write	buffer.c	/^int req_write(request * req, char *msg)$/;"	f
req_write_escape_html	buffer.c	/^int req_write_escape_html(request * req, char *msg)$/;"	f
req_write_escape_http	buffer.c	/^int req_write_escape_http(request * req, char *msg)$/;"	f
request	globals.h	/^struct request {                \/* pending requests *\/$/;"	s
request	globals.h	/^typedef struct request request;$/;"	t
request_block	queue.c	/^request *request_block = NULL;  \/* blocked list head *\/$/;"	v
request_free	queue.c	/^request *request_free = NULL;   \/* free list head *\/$/;"	v
request_ready	queue.c	/^request *request_ready = NULL;  \/* ready list head *\/$/;"	v
request_uri	globals.h	/^    char request_uri[MAX_HEADER_LENGTH + 1]; \/* uri *\/$/;"	m	struct:request
requests	globals.h	/^    long requests;$/;"	m	struct:status
response_status	globals.h	/^    int response_status;        \/* R_NOT_FOUND etc. *\/$/;"	m	struct:request
rfc822_time_buf	util.c	/^void rfc822_time_buf(char *buf, time_t s)$/;"	f
script_name	globals.h	/^    char *script_name;          \/* env variable *\/$/;"	m	struct:request
script_number	config.c	/^int script_number = SCRIPTALIAS;$/;"	v
sdbm_hash	hash.c	/^static unsigned sdbm_hash(char *str)$/;"	f	file:
select_files	index_dir.c	/^int select_files(CONST struct dirent *dirbuf)$/;"	f
send_error	index_dir.c	/^void send_error(int error)$/;"	f
send_r_bad_request	response.c	/^void send_r_bad_request(request * req)$/;"	f
send_r_bad_version	response.c	/^void send_r_bad_version(request * req)$/;"	f
send_r_error	response.c	/^void send_r_error(request * req)$/;"	f
send_r_forbidden	response.c	/^void send_r_forbidden(request * req)$/;"	f
send_r_not_found	response.c	/^void send_r_not_found(request * req)$/;"	f
send_r_not_implemented	response.c	/^void send_r_not_implemented(request * req)$/;"	f
send_r_not_modified	response.c	/^void send_r_not_modified(request * req)$/;"	f
send_r_request_ok	response.c	/^void send_r_request_ok(request * req)$/;"	f
send_r_unauthorized	response.c	/^void send_r_unauthorized(request * req, char *realm_name)$/;"	f
send_redirect_perm	response.c	/^void send_redirect_perm(request * req, char *url)$/;"	f
send_redirect_temp	response.c	/^void send_redirect_temp(request * req, char *url, char *more_hdr)$/;"	f
server_admin	config.c	/^char *server_admin;$/;"	v
server_gid	config.c	/^gid_t server_gid;$/;"	v
server_ip	config.c	/^char *server_ip = NULL;$/;"	v
server_name	config.c	/^char *server_name;$/;"	v
server_port	config.c	/^int server_port;$/;"	v
server_root	config.c	/^char *server_root;$/;"	v
server_s	boa.c	/^int server_s;                   \/* boa socket *\/$/;"	v
server_uid	config.c	/^uid_t server_uid;$/;"	v
show_hash_stats	hash.c	/^void show_hash_stats(void)$/;"	f
sigalrm	signals.c	/^void sigalrm(int dummy)$/;"	f
sigbus	signals.c	/^void sigbus(int dummy)$/;"	f
sigchld	signals.c	/^void sigchld(int dummy)$/;"	f
sigchld_flag	boa.c	/^int sigchld_flag = 0;           \/* 1 => signal has happened, needs attention *\/$/;"	v
sigchld_run	signals.c	/^void sigchld_run(void)$/;"	f
sighup	signals.c	/^void sighup(int dummy)$/;"	f
sighup_flag	boa.c	/^int sighup_flag = 0;            \/* 1 => signal has happened, needs attention *\/$/;"	v
sighup_run	signals.c	/^void sighup_run(void)$/;"	f
sigint	signals.c	/^void sigint(int dummy)$/;"	f
sigsegv	signals.c	/^void sigsegv(int dummy)$/;"	f
sigterm	signals.c	/^void sigterm(int dummy)$/;"	f
simple	globals.h	/^    int simple;                 \/* simple request? *\/$/;"	m	struct:request
simple_itoa	util.c	/^char *simple_itoa(int i)$/;"	f
single_post_limit	config.c	/^int single_post_limit;$/;"	v
sock_opt	boa.c	/^int sock_opt = 1;$/;"	v
sockbufsize	request.c	/^int sockbufsize = SOCKETBUF_SIZE;$/;"	v
status	globals.h	/^    int status;                 \/* see #defines.h *\/$/;"	m	struct:request
status	globals.h	/^struct status status;$/;"	v
status	globals.h	/^struct status {$/;"	s
str	lex.yy.c	458;"	d	file:
strdup	util.c	/^char *strdup(char *s)$/;"	f
string_buf	lex.yy.c	/^char string_buf[MAX_STR_CONST];$/;"	v
string_buf_ptr	lex.yy.c	/^char *string_buf_ptr;$/;"	v
strstr	util.c	/^char *strstr(char *s1, char *s2)$/;"	f
sval	y.tab.c	/^    char *	sval;$/;"	m	union:	file:
sval	y.tab.h	/^    char *	sval;$/;"	m	union:
tempdir	config.c	/^char *tempdir;$/;"	v
time_last	globals.h	/^    time_t time_last;           \/* time of last succ. op. *\/$/;"	m	struct:request
timestamp	timestamp.c	/^void timestamp(void)$/;"	f
to_upper	util.c	/^char *to_upper(char *str)$/;"	f
total_connections	request.c	/^int total_connections;$/;"	v
translate_uri	alias.c	/^int translate_uri(request * req)$/;"	f
type	globals.h	/^    int type;                   \/* ALIAS, SCRIPTALIAS, REDIRECT *\/$/;"	m	struct:alias
type	parse.h	/^    int type;$/;"	m	struct:ccommand
unescape_uri	util.c	/^int unescape_uri(char *uri, char ** query_string)$/;"	f
unput	lex.yy.c	135;"	d	file:
use_count	globals.h	/^    int use_count;$/;"	m	struct:mmap_entry
use_localtime	config.c	/^int use_localtime = 0;$/;"	v
user_dir	config.c	/^char *user_dir;$/;"	v
value	hash.c	/^    char *value;$/;"	m	struct:_hash_struct_	file:
verbose_cgi_logs	cgi.c	/^int verbose_cgi_logs = 0;$/;"	v
virtualhost	config.c	/^int virtualhost = 0;$/;"	v
write_body	read.c	/^int write_body(request * req)$/;"	f
write_from_pipe	pipe.c	/^int write_from_pipe(request * req)$/;"	f
yy_accept	lex.yy.c	/^static yyconst short int yy_accept[49] =$/;"	v	file:
yy_at_bol	lex.yy.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	lex.yy.c	/^static yyconst short int yy_base[64] =$/;"	v	file:
yy_buf_pos	lex.yy.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	lex.yy.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_state	lex.yy.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	lex.yy.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	lex.yy.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	lex.yy.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	lex.yy.c	/^static yyconst short int yy_chk[157] =$/;"	v	file:
yy_create_buffer	lex.yy.c	/^YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )$/;"	f
yy_current_buffer	lex.yy.c	/^static YY_BUFFER_STATE yy_current_buffer = 0;$/;"	v	file:
yy_def	lex.yy.c	/^static yyconst short int yy_def[64] =$/;"	v	file:
yy_delete_buffer	lex.yy.c	/^void yy_delete_buffer( YY_BUFFER_STATE b )$/;"	f
yy_did_buffer_switch_on_eof	lex.yy.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	lex.yy.c	/^static yyconst int yy_ec[256] =$/;"	v	file:
yy_fatal_error	lex.yy.c	/^static void yy_fatal_error( yyconst char msg[] )$/;"	f	file:
yy_fill_buffer	lex.yy.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_alloc	lex.yy.c	/^static void *yy_flex_alloc( yy_size_t size )$/;"	f	file:
yy_flex_free	lex.yy.c	/^static void yy_flex_free( void *ptr )$/;"	f	file:
yy_flex_realloc	lex.yy.c	/^static void *yy_flex_realloc( void *ptr, yy_size_t size )$/;"	f	file:
yy_flex_strlen	lex.yy.c	/^static int yy_flex_strlen( yyconst char *s )$/;"	f	file:
yy_flex_strncpy	lex.yy.c	/^static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )$/;"	f	file:
yy_flush_buffer	lex.yy.c	/^void yy_flush_buffer( YY_BUFFER_STATE b )$/;"	f
yy_get_next_buffer	lex.yy.c	/^static int yy_get_next_buffer()$/;"	f	file:
yy_get_previous_state	lex.yy.c	/^static yy_state_type yy_get_previous_state()$/;"	f	file:
yy_hold_char	lex.yy.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	lex.yy.c	/^static int yy_init = 1;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	lex.yy.c	/^void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )$/;"	f
yy_input_file	lex.yy.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	lex.yy.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	lex.yy.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	lex.yy.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	lex.yy.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	lex.yy.c	/^void yy_load_buffer_state( void )$/;"	f
yy_meta	lex.yy.c	/^static yyconst int yy_meta[15] =$/;"	v	file:
yy_n_chars	lex.yy.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	lex.yy.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	lex.yy.c	246;"	d	file:
yy_nxt	lex.yy.c	/^static yyconst short int yy_nxt[157] =$/;"	v	file:
yy_pop_state	lex.yy.c	/^static void yy_pop_state()$/;"	f	file:
yy_push_state	lex.yy.c	/^static void yy_push_state( int new_state )$/;"	f	file:
yy_scan_buffer	lex.yy.c	/^YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )$/;"	f
yy_scan_bytes	lex.yy.c	/^YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )$/;"	f
yy_scan_string	lex.yy.c	/^YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )$/;"	f
yy_set_bol	lex.yy.c	255;"	d	file:
yy_set_interactive	lex.yy.c	248;"	d	file:
yy_size_t	lex.yy.c	/^typedef unsigned int yy_size_t;$/;"	t	file:
yy_start	lex.yy.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_start_stack	lex.yy.c	/^static int *yy_start_stack = 0;$/;"	v	file:
yy_start_stack_depth	lex.yy.c	/^static int yy_start_stack_depth = 0;$/;"	v	file:
yy_start_stack_ptr	lex.yy.c	/^static int yy_start_stack_ptr = 0;$/;"	v	file:
yy_state_type	lex.yy.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	lex.yy.c	/^void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )$/;"	f
yy_top_state	lex.yy.c	/^static int yy_top_state()$/;"	f	file:
yy_try_NUL_trans	lex.yy.c	/^static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )$/;"	f	file:
yychar	y.tab.c	/^int	yychar;			\/*  the lookahead symbol		*\/$/;"	v
yycheck	y.tab.c	/^static const short yycheck[] = {     3,$/;"	v	file:
yyclearin	y.tab.c	272;"	d	file:
yyconst	lex.yy.c	53;"	d	file:
yyconst	lex.yy.c	55;"	d	file:
yydebug	y.tab.c	/^int yydebug;			\/*  nonzero means print parse trace	*\/$/;"	v
yydefact	y.tab.c	/^static const short yydefact[] = {     3,$/;"	v	file:
yydefgoto	y.tab.c	/^static const short yydefgoto[] = {    20,$/;"	v	file:
yyerrok	y.tab.c	271;"	d	file:
yyerror	lex.yy.c	/^int yyerror(char * msg)$/;"	f
yyin	lex.yy.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yyinput	lex.yy.c	/^static int yyinput()$/;"	f	file:
yyleng	lex.yy.c	/^int yyleng;$/;"	v
yyless	lex.yy.c	124;"	d	file:
yyless	lex.yy.c	1616;"	d	file:
yyless	lex.yy.c	1617;"	d	file:
yylloc	y.tab.c	/^YYLTYPE yylloc;			\/*  location data for the lookahead	*\/$/;"	v
yylval	y.tab.c	/^YYSTYPE	yylval;			\/*  the semantic value of the		*\/$/;"	v
yymore	lex.yy.c	405;"	d	file:
yynerrs	y.tab.c	/^int yynerrs;			\/*  number of parse errors so far       *\/$/;"	v
yyout	lex.yy.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yypact	y.tab.c	/^static const short yypact[] = {-32768,$/;"	v	file:
yyparse	y.tab.c	/^yyparse(YYPARSE_PARAM_ARG)$/;"	f
yypgoto	y.tab.c	/^static const short yypgoto[] = {-32768,$/;"	v	file:
yyprhs	y.tab.c	/^static const short yyprhs[] = {     0,$/;"	v	file:
yyr1	y.tab.c	/^static const short yyr1[] = {     0,$/;"	v	file:
yyr2	y.tab.c	/^static const short yyr2[] = {     0,$/;"	v	file:
yyrestart	lex.yy.c	/^void yyrestart( FILE *input_file )$/;"	f
yyrhs	y.tab.c	/^static const short yyrhs[] = {    10,$/;"	v	file:
yyrline	y.tab.c	/^static const short yyrline[] = { 0,$/;"	v	file:
yytable	y.tab.c	/^static const short yytable[] = {     2,$/;"	v	file:
yyterminate	lex.yy.c	570;"	d	file:
yytext	lex.yy.c	/^char *yytext;$/;"	v
yytext_ptr	lex.yy.c	268;"	d	file:
yytname	y.tab.c	/^static const char * const yytname[] = {   "$","error","$undefined.","STMT_NO_ARGS",$/;"	v	file:
yytranslate	y.tab.c	/^static const char yytranslate[] = {     0,$/;"	v	file:
yyunput	lex.yy.c	/^static void yyunput( int c, register char *yy_bp )$/;"	f	file:
yywrap	configure	/^yywrap()$/;"	f
yywrap	lex.yy.c	/^int yywrap()$/;"	f
