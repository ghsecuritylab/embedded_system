!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/darren@hiebert.com/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.0.1	//
ACKCIADDR	ipcp.c	823;"	d	file:
ACKCICHAP	lcp.c	798;"	d	file:
ACKCICHAR	lcp.c	785;"	d	file:
ACKCICHARS	ipxcp.c	658;"	d	file:
ACKCICOMPLETE	ipxcp.c	656;"	d	file:
ACKCIDNS	ipcp.c	846;"	d	file:
ACKCIENDP	lcp.c	843;"	d	file:
ACKCIIFACEID	ipv6cp.c	585;"	d	file:
ACKCILONG	lcp.c	814;"	d	file:
ACKCILQR	lcp.c	827;"	d	file:
ACKCINAME	ipxcp.c	679;"	d	file:
ACKCINETWORK	ipxcp.c	681;"	d	file:
ACKCINODE	ipxcp.c	678;"	d	file:
ACKCIPROTO	ipxcp.c	695;"	d	file:
ACKCISHORT	lcp.c	772;"	d	file:
ACKCIVJ	ipcp.c	800;"	d	file:
ACKCIVJ	ipv6cp.c	570;"	d	file:
ACKCIVOID	ipxcp.c	645;"	d	file:
ACKCIVOID	lcp.c	762;"	d	file:
ACKRCVD	fsm.h	106;"	d
ACKSENT	fsm.h	107;"	d
ACTIVE_LOCK	tdb.c	46;"	d	file:
ADDCIADDR	ipcp.c	730;"	d	file:
ADDCICHAP	lcp.c	680;"	d	file:
ADDCICHAR	lcp.c	700;"	d	file:
ADDCIDNS	ipcp.c	748;"	d	file:
ADDCIENDP	lcp.c	706;"	d	file:
ADDCIIFACEID	ipv6cp.c	527;"	d	file:
ADDCILONG	lcp.c	687;"	d	file:
ADDCILQR	lcp.c	693;"	d	file:
ADDCISHORT	lcp.c	674;"	d	file:
ADDCIVJ	ipcp.c	714;"	d	file:
ADDCIVJ	ipv6cp.c	515;"	d	file:
ADDCIVOID	lcp.c	669;"	d	file:
AHDLC_MOD_NAME	sys-solaris.c	101;"	d	file:
ANY_COMPRESS	ccp.c	177;"	d	file:
AR	Makefile	/^AR = $(CROSS)ar$/;"	m
BCOPY	pppd.h	659;"	d
BINDIR	Makefile	/^BINDIR = \/usr\/sbin$/;"	m
BIT	ipxcp.c	203;"	d	file:
BUCKET	tdb.c	49;"	d	file:
BZERO	pppd.h	660;"	d
C2	md4.c	49;"	d	file:
C3	md4.c	50;"	d	file:
CALLBACK_DIALIN	pppd.h	222;"	d
CALLBACK_DIALOUT	pppd.h	223;"	d
CBCP_ACK	cbcp.h	20;"	d
CBCP_H	cbcp.h	2;"	d
CBCP_MINLEN	cbcp.h	16;"	d
CBCP_OPT	lcp.h	44;"	d
CBCP_REQ	cbcp.h	18;"	d
CBCP_RESP	cbcp.h	19;"	d
CB_CONF_ADMIN	cbcp.h	24;"	d
CB_CONF_LIST	cbcp.h	25;"	d
CB_CONF_NO	cbcp.h	22;"	d
CB_CONF_USER	cbcp.h	23;"	d
CC	Makefile	/^CC = $(CROSS)gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS= $(COPTS) $(COMPILE_FLAGS) $(INCLUDE_DIRS)$/;"	m
CHAPCS_CLOSED	chap.h	93;"	d
CHAPCS_INITIAL	chap.h	92;"	d
CHAPCS_LISTEN	chap.h	95;"	d
CHAPCS_OPEN	chap.h	97;"	d
CHAPCS_PENDING	chap.h	94;"	d
CHAPCS_RESPONSE	chap.h	96;"	d
CHAPDEBUG	pppd.h	763;"	d
CHAPDEBUG	pppd.h	765;"	d
CHAPMS	Makefile	/^CHAPMS=y$/;"	m
CHAPSS_BADAUTH	chap.h	108;"	d
CHAPSS_CLOSED	chap.h	103;"	d
CHAPSS_INITIAL	chap.h	102;"	d
CHAPSS_INITIAL_CHAL	chap.h	105;"	d
CHAPSS_OPEN	chap.h	106;"	d
CHAPSS_PENDING	chap.h	104;"	d
CHAPSS_RECHALLENGE	chap.h	107;"	d
CHAP_CHALLENGE	chap.h	50;"	d
CHAP_DEFTIMEOUT	chap.h	113;"	d
CHAP_DEFTRANSMITS	chap.h	114;"	d
CHAP_DIGEST_MD5	chap.h	45;"	d
CHAP_FAILURE	chap.h	53;"	d
CHAP_HEADERLEN	chap.h	39;"	d
CHAP_MICROSOFT	chap.h	47;"	d
CHAP_PEER	auth.c	169;"	d	file:
CHAP_RESPONSE	chap.h	51;"	d
CHAP_SUCCESS	chap.h	52;"	d
CHAP_WITHPEER	auth.c	168;"	d	file:
CILEN_ADDR	ipcp.c	241;"	d	file:
CILEN_ADDRS	ipcp.c	242;"	d	file:
CILEN_CBCP	lcp.c	268;"	d	file:
CILEN_CHAP	lcp.c	265;"	d	file:
CILEN_CHAR	lcp.c	263;"	d	file:
CILEN_COMPLETE	ipxcp.c	185;"	d	file:
CILEN_COMPRESS	ipcp.c	239;"	d	file:
CILEN_COMPRESS	ipv6cp.c	258;"	d	file:
CILEN_COMPRESS	ipxcp.c	190;"	d	file:
CILEN_IFACEID	ipv6cp.c	259;"	d	file:
CILEN_LONG	lcp.c	266;"	d	file:
CILEN_LQR	lcp.c	267;"	d	file:
CILEN_NAME	ipxcp.c	189;"	d	file:
CILEN_NETN	ipxcp.c	186;"	d	file:
CILEN_NODEN	ipxcp.c	187;"	d	file:
CILEN_PROTOCOL	ipxcp.c	188;"	d	file:
CILEN_SHORT	lcp.c	264;"	d	file:
CILEN_VJ	ipcp.c	240;"	d	file:
CILEN_VOID	ipcp.c	238;"	d	file:
CILEN_VOID	ipv6cp.c	257;"	d	file:
CILEN_VOID	ipxcp.c	184;"	d	file:
CILEN_VOID	lcp.c	262;"	d	file:
CI_ACCOMPRESSION	lcp.h	31;"	d
CI_ADDR	ipcp.h	27;"	d
CI_ADDRS	ipcp.h	25;"	d
CI_ASYNCMAP	lcp.h	26;"	d
CI_AUTHTYPE	lcp.h	27;"	d
CI_CALLBACK	lcp.h	32;"	d
CI_COMPRESSTYPE	ipcp.h	26;"	d
CI_COMPRESSTYPE	ipv6cp.h	100;"	d
CI_EPDISC	lcp.h	35;"	d
CI_IFACEID	ipv6cp.h	99;"	d
CI_MAGICNUMBER	lcp.h	29;"	d
CI_MRRU	lcp.h	33;"	d
CI_MRU	lcp.h	25;"	d
CI_MS_DNS1	ipcp.h	29;"	d
CI_MS_DNS2	ipcp.h	31;"	d
CI_MS_WINS1	ipcp.h	30;"	d
CI_MS_WINS2	ipcp.h	32;"	d
CI_PCOMPRESSION	lcp.h	30;"	d
CI_QUALITY	lcp.h	28;"	d
CI_SSNHF	lcp.h	34;"	d
CLOSED	fsm.h	101;"	d
CLOSING	fsm.h	103;"	d
CODENAME	ipcp.c	245;"	d	file:
CODENAME	ipv6cp.c	261;"	d	file:
CODENAME	ipxcp.c	192;"	d	file:
CODENAME	lcp.c	270;"	d	file:
CODEREJ	fsm.h	37;"	d
COMPILE_FLAGS	Makefile	/^COMPILE_FLAGS= -D_linux_=1 -DHAVE_PATHS_H -DIPX_CHANGE -DHAVE_MULTILINK -DHAVE_MMAP$/;"	m
COMP_MOD_NAME	sys-solaris.c	105;"	d	file:
CONFACK	fsm.h	32;"	d
CONFNAK	fsm.h	33;"	d
CONFREJ	fsm.h	34;"	d
CONFREQ	fsm.h	31;"	d
COPTS	Makefile	/^COPTS = -O2 -pipe -Wall -g$/;"	m
COPY_STRING	auth.c	1039;"	d	file:
CROSS	Makefile	/^CROSS = \/home\/hhcn\/toolchain\/gcc-3.2.2\/toolchain\/bin\/powerpc-uclibc-$/;"	m
ChallengeResponse	chap_ms.c	/^ChallengeResponse(challenge, pwHash, response)$/;"	f	file:
ChapAuthPeer	chap.c	/^ChapAuthPeer(unit, our_name, digest)$/;"	f
ChapAuthWithPeer	chap.c	/^ChapAuthWithPeer(unit, our_name, digest)$/;"	f
ChapChallengeTimeout	chap.c	/^ChapChallengeTimeout(arg)$/;"	f	file:
ChapCodenames	chap.c	/^static char *ChapCodenames[] = {$/;"	v	file:
ChapGenChallenge	chap.c	/^ChapGenChallenge(cstate)$/;"	f	file:
ChapInit	chap.c	/^ChapInit(unit)$/;"	f	file:
ChapInput	chap.c	/^ChapInput(unit, inpacket, packet_len)$/;"	f	file:
ChapLowerDown	chap.c	/^ChapLowerDown(unit)$/;"	f	file:
ChapLowerUp	chap.c	/^ChapLowerUp(unit)$/;"	f	file:
ChapMS	chap_ms.c	/^ChapMS(cstate, rchallenge, rchallenge_len, secret, secret_len)$/;"	f
ChapMS_LANMan	chap_ms.c	/^ChapMS_LANMan(rchallenge, rchallenge_len, secret, secret_len, response)$/;"	f	file:
ChapMS_NT	chap_ms.c	/^ChapMS_NT(rchallenge, rchallenge_len, secret, secret_len, response)$/;"	f	file:
ChapPrintPkt	chap.c	/^ChapPrintPkt(p, plen, printer, arg)$/;"	f	file:
ChapProtocolReject	chap.c	/^ChapProtocolReject(unit)$/;"	f	file:
ChapReceiveChallenge	chap.c	/^ChapReceiveChallenge(cstate, inp, id, len)$/;"	f	file:
ChapReceiveFailure	chap.c	/^ChapReceiveFailure(cstate, inp, id, len)$/;"	f	file:
ChapReceiveResponse	chap.c	/^ChapReceiveResponse(cstate, inp, id, len)$/;"	f	file:
ChapReceiveSuccess	chap.c	/^ChapReceiveSuccess(cstate, inp, id, len)$/;"	f	file:
ChapRechallenge	chap.c	/^ChapRechallenge(arg)$/;"	f	file:
ChapResponseTimeout	chap.c	/^ChapResponseTimeout(arg)$/;"	f	file:
ChapSendChallenge	chap.c	/^ChapSendChallenge(cstate)$/;"	f	file:
ChapSendResponse	chap.c	/^ChapSendResponse(cstate)$/;"	f	file:
ChapSendStatus	chap.c	/^ChapSendStatus(cstate, code)$/;"	f	file:
Collapse	chap_ms.c	/^static void Collapse(in, out)$/;"	f	file:
DATE	patchlevel.h	4;"	d
DEBUGCHAP	pppd.h	707;"	d
DEBUGFSM	pppd.h	702;"	d
DEBUGIPCP	pppd.h	704;"	d
DEBUGIPV6CP	pppd.h	705;"	d
DEBUGLCP	pppd.h	703;"	d
DEBUGMAIN	pppd.h	701;"	d
DEBUGUPAP	pppd.h	706;"	d
DECPTR	pppd.h	650;"	d
DEFAULT_HASH_SIZE	tdb.c	36;"	d	file:
DEFLATE_MIN_WORKS	ccp.c	47;"	d	file:
DEFLOOPBACKFAIL	lcp.h	95;"	d
DEFMAXCONFREQS	fsm.h	124;"	d
DEFMAXNAKLOOPS	fsm.h	125;"	d
DEFMAXTERMREQS	fsm.h	123;"	d
DEFMRU	lcp.h	81;"	d
DEFTIMEOUT	fsm.h	122;"	d
DELAYED_UP	lcp.c	44;"	d	file:
DISCREQ	lcp.h	43;"	d
DesEncrypt	chap_ms.c	/^DesEncrypt(clear, key, cipher)$/;"	f	file:
ECHOREP	lcp.h	42;"	d
ECHOREQ	lcp.h	41;"	d
EPD_IP	pppd.h	169;"	d
EPD_LOCAL	pppd.h	168;"	d
EPD_MAC	pppd.h	170;"	d
EPD_MAGIC	pppd.h	171;"	d
EPD_NULL	pppd.h	167;"	d
EPD_PHONENUM	pppd.h	172;"	d
EXIT_AUTH_TOPEER_FAILED	pppd.h	694;"	d
EXIT_CALLBACK	pppd.h	689;"	d
EXIT_CONNECT_FAILED	pppd.h	683;"	d
EXIT_CONNECT_TIME	pppd.h	688;"	d
EXIT_FATAL_ERROR	pppd.h	676;"	d
EXIT_HANGUP	pppd.h	691;"	d
EXIT_IDLE_TIMEOUT	pppd.h	687;"	d
EXIT_INIT_FAILED	pppd.h	693;"	d
EXIT_LOCK_FAILED	pppd.h	681;"	d
EXIT_LOOPBACK	pppd.h	692;"	d
EXIT_NEGOTIATION_FAILED	pppd.h	685;"	d
EXIT_NOT_ROOT	pppd.h	678;"	d
EXIT_NO_KERNEL_SUPPORT	pppd.h	679;"	d
EXIT_OK	pppd.h	675;"	d
EXIT_OPEN_FAILED	pppd.h	682;"	d
EXIT_OPTION_ERROR	pppd.h	677;"	d
EXIT_PEER_AUTH_FAILED	pppd.h	686;"	d
EXIT_PEER_DEAD	pppd.h	690;"	d
EXIT_PTYCMD_FAILED	pppd.h	684;"	d
EXIT_USER_REQUEST	pppd.h	680;"	d
Expand	chap_ms.c	/^static void Expand(in, out)$/;"	f	file:
F	md5.c	64;"	d	file:
FALSE	md4.c	35;"	d	file:
FF	md5.c	74;"	d	file:
FLAGS_GOOD	sys-linux.c	164;"	d	file:
FLAGS_MASK	sys-linux.c	165;"	d	file:
FREELIST_TOP	tdb.c	39;"	d	file:
FSMDEBUG	pppd.h	733;"	d
FSMDEBUG	pppd.h	735;"	d
G	md5.c	65;"	d	file:
GETCHAR	pppd.h	619;"	d
GETLONG	pppd.h	636;"	d
GETSHORT	pppd.h	627;"	d
GG	md5.c	79;"	d	file:
GIDSET_TYPE	pppd.h	131;"	d
GLOBAL_LOCK	tdb.c	45;"	d	file:
Get7Bits	chap_ms.c	/^static u_char Get7Bits(input, startBit)$/;"	f	file:
GetMask	sys-linux.c	/^u_int32_t GetMask (u_int32_t addr)$/;"	f
GetMask	sys-solaris.c	/^GetMask(addr)$/;"	f
GetMask	sys-sunos4.c	/^GetMask(addr)$/;"	f
H	md5.c	66;"	d	file:
HAS_SHADOW	Makefile	/^HAS_SHADOW=y$/;"	m
HAVE_CRYPT_H	Makefile	/^HAVE_CRYPT_H=y$/;"	m
HDB	sys-sunos4.c	1383;"	d	file:
HEADERLEN	fsm.h	25;"	d
HEADERS	Makefile	/^HEADERS =  callout.h pathnames.h patchlevel.h chap.h md5.h chap_ms.h md4.h \\$/;"	m
HH	md5.c	84;"	d	file:
I	md5.c	67;"	d	file:
I0	md4.c	45;"	d	file:
I1	md4.c	46;"	d	file:
I2	md4.c	47;"	d	file:
I3	md4.c	48;"	d	file:
II	md5.c	89;"	d	file:
IMPLEMENTATION	options.c	269;"	d	file:
IN6_LLADDR_FROM_EUI64	sys-linux.c	109;"	d	file:
IN6_LLADDR_FROM_EUI64	sys-solaris.c	156;"	d	file:
IN6_LLTOKEN_FROM_EUI64	sys-solaris.c	159;"	d	file:
INCLUDE_DIRS	Makefile	/^INCLUDE_DIRS= -I..\/include$/;"	m
INCPTR	pppd.h	649;"	d
INET_ADDR	sys-solaris.c	1913;"	d	file:
INET_ADDR	sys-sunos4.c	996;"	d	file:
INITIAL	fsm.h	99;"	d
INSTALL	Makefile	/^INSTALL= install -o root$/;"	m
IP6_HDRLEN	ipv6cp.c	1476;"	d	file:
IP6_NHDR_FRAG	ipv6cp.c	1477;"	d	file:
IPCPDEBUG	pppd.h	745;"	d
IPCPDEBUG	pppd.h	747;"	d
IPCP_VJMODE_OLD	ipcp.h	36;"	d
IPCP_VJMODE_RFC1172	ipcp.h	37;"	d
IPCP_VJMODE_RFC1332	ipcp.h	38;"	d
IPCP_VJ_COMP	ipcp.h	41;"	d
IPCP_VJ_COMP_OLD	ipcp.h	42;"	d
IPPROTO_TCP	ipcp.c	2015;"	d	file:
IPPROTO_TCP	ipv6cp.c	1478;"	d	file:
IPV6CPDEBUG	pppd.h	751;"	d
IPV6CPDEBUG	pppd.h	753;"	d
IPXCPDEBUG	pppd.h	769;"	d
IPXCPDEBUG	pppd.h	771;"	d
IPX_COMPLETE	ipxcp.h	30;"	d
IPX_COMPRESSION_PROTOCOL	ipxcp.h	27;"	d
IPX_NETWORK_NUMBER	ipxcp.h	25;"	d
IPX_NODE_NUMBER	ipxcp.h	26;"	d
IPX_NONE	ipxcp.h	33;"	d
IPX_ROUTER_NAME	ipxcp.h	29;"	d
IPX_ROUTER_PROTOCOL	ipxcp.h	28;"	d
IP_DEV_NAME	sys-solaris.c	109;"	d	file:
IP_HDRLEN	ipcp.c	2013;"	d	file:
IP_MOD_NAME	sys-solaris.c	113;"	d	file:
IP_OFFMASK	ipcp.c	2014;"	d	file:
ISWILD	auth.c	85;"	d	file:
KVERSION	sys-linux.c	160;"	d	file:
LANManResp	chap_ms.c	/^    u_char LANManResp[24];$/;"	m	struct:	file:
LCPDEBUG	pppd.h	739;"	d
LCPDEBUG	pppd.h	741;"	d
LENCIADDR	ipcp.c	672;"	d	file:
LENCICBCP	lcp.c	637;"	d	file:
LENCICHAP	lcp.c	633;"	d	file:
LENCIDNS	ipcp.c	673;"	d	file:
LENCIIFACEID	ipv6cp.c	496;"	d	file:
LENCILONG	lcp.c	635;"	d	file:
LENCILQR	lcp.c	636;"	d	file:
LENCISHORT	lcp.c	634;"	d	file:
LENCIVJ	ipcp.c	671;"	d	file:
LENCIVJ	ipv6cp.c	495;"	d	file:
LENCIVOID	lcp.c	632;"	d	file:
LIBS	Makefile	/^LIBS     := -ldes $(LIBS)$/;"	m
LIBS	Makefile	/^LIBS     := -llock $(LIBS)$/;"	m
LIBS	Makefile	/^LIBS     := -lpam -ldl $(LIBS)$/;"	m
LIBS	Makefile	/^LIBS =$/;"	m
LIST_LOCK_BASE	tdb.c	47;"	d	file:
LOCAL_IP_ADDR	multilink.c	47;"	d	file:
LOCK_CLEAR	tdb.c	42;"	d	file:
LOCK_DIR	utils.c	767;"	d	file:
LOCK_DIR	utils.c	770;"	d	file:
LOCK_DIR	utils.c	772;"	d	file:
LOCK_PREFIX	sys-solaris.c	2477;"	d	file:
LOCK_PREFIX	sys-sunos4.c	1389;"	d	file:
LOCK_PREFIX	sys-sunos4.c	1391;"	d	file:
LOCK_SET	tdb.c	41;"	d	file:
LOG_PPP	pppd.h	714;"	d
LOG_PPP	pppd.h	716;"	d
LcpEchoCheck	lcp.c	/^LcpEchoCheck (f)$/;"	f	file:
LcpEchoTimeout	lcp.c	/^LcpEchoTimeout (arg)$/;"	f	file:
LcpLinkFailure	lcp.c	/^void LcpLinkFailure (f)$/;"	f	file:
LcpSendEchoRequest	lcp.c	/^LcpSendEchoRequest (f)$/;"	f	file:
MAINDEBUG	pppd.h	721;"	d
MAINDEBUG	pppd.h	723;"	d
MAKEHEADER	pppd.h	667;"	d
MANDIR	Makefile	/^MANDIR = \/usr\/man$/;"	m
MANPAGES	Makefile	/^MANPAGES = pppd.8$/;"	m
MAP_FILE	tdb.c	52;"	d	file:
MAX	pppd.h	786;"	d
MAXARGS	pppd.h	57;"	d
MAXIFS	sys-solaris.c	168;"	d	file:
MAXMRU	lcp.h	83;"	d
MAXNAMELEN	pppd.h	58;"	d
MAXSECRETLEN	pppd.h	59;"	d
MAXWORDLEN	pppd.h	56;"	d
MAX_ADDR_LEN	sys-linux.c	51;"	d	file:
MAX_CHALLENGE_LENGTH	chap.h	59;"	d
MAX_ENDP_LEN	pppd.h	159;"	d
MAX_IFS	sys-linux.c	162;"	d	file:
MAX_IFS	sys-solaris.c	2104;"	d	file:
MAX_IFS	sys-sunos4.c	1164;"	d	file:
MAX_NT_PASSWORD	chap_ms.h	28;"	d
MAX_POLLFDS	sys-solaris.c	182;"	d	file:
MAX_POLLFDS	sys-sunos4.c	82;"	d	file:
MAX_RESPONSE_LENGTH	chap.h	60;"	d
MAX_STATES	ipcp.h	34;"	d
MD4Final	md4.c	/^MD4Final(buf, MD)$/;"	f
MD4Init	md4.c	/^MD4Init(MDp)$/;"	f
MD4Print	md4.c	/^MD4Print(MDp)$/;"	f
MD4Update	md4.c	/^MD4Update(MDp,X,count)$/;"	f
MD4_CTX	md4.h	/^} MD4_CTX;$/;"	t
MD4_SIGNATURE_SIZE	chap_ms.h	27;"	d
MD5Final	md5.c	/^void MD5Final (hash, mdContext)$/;"	f
MD5Init	md5.c	/^void MD5Init (mdContext)$/;"	f
MD5Update	md5.c	/^void MD5Update (mdContext, inBuf, inLen)$/;"	f
MD5_CTX	md5.h	/^} MD5_CTX;$/;"	t
MD5_SIGNATURE_SIZE	chap.h	46;"	d
MDblock	md4.c	/^MDblock(MDp,Xb)$/;"	f	file:
MIN	pppd.h	783;"	d
MINMRU	lcp.h	82;"	d
MIN_CHALLENGE_LENGTH	chap.h	58;"	d
MIN_REC_SIZE	tdb.c	35;"	d	file:
MS_CHAP_RESPONSE_LEN	chap.h	48;"	d
MS_ChapResponse	chap_ms.c	/^} MS_ChapResponse;$/;"	t	file:
MakeKey	chap_ms.c	/^static void MakeKey(key, des_key)$/;"	f	file:
NAKCIADDR	ipcp.c	915;"	d	file:
NAKCICHAP	lcp.c	933;"	d	file:
NAKCICHAR	lcp.c	945;"	d	file:
NAKCIDNS	ipcp.c	946;"	d	file:
NAKCIENDP	lcp.c	990;"	d	file:
NAKCIIFACEID	ipv6cp.c	646;"	d	file:
NAKCILONG	lcp.c	967;"	d	file:
NAKCILQR	lcp.c	978;"	d	file:
NAKCISHORT	lcp.c	956;"	d	file:
NAKCIVJ	ipcp.c	934;"	d	file:
NAKCIVJ	ipv6cp.c	658;"	d	file:
NAKCIVOID	lcp.c	923;"	d	file:
NLSP	ipxcp.h	35;"	d
NMODULES	sys-solaris.c	188;"	d	file:
NMODULES	sys-sunos4.c	88;"	d	file:
NODE	ipxcp.c	200;"	d	file:
NONWILD_CLIENT	auth.c	83;"	d	file:
NONWILD_SERVER	auth.c	82;"	d	file:
NTResp	chap_ms.c	/^    u_char NTResp[24];$/;"	m	struct:	file:
NUM_PPP	pppd.h	55;"	d
N_SYNC_PPP	sys-linux.c	385;"	d	file:
OPENED	fsm.h	108;"	d
OPRIO_CFGFILE	pppd.h	125;"	d
OPRIO_CMDLINE	pppd.h	126;"	d
OPRIO_DEFAULT	pppd.h	124;"	d
OPRIO_ROOT	pppd.h	128;"	d
OPRIO_SECFILE	pppd.h	127;"	d
OPT_A2CLR	pppd.h	112;"	d
OPT_A2COPY	pppd.h	110;"	d
OPT_A2LIST	pppd.h	104;"	d
OPT_A2PRINTER	pppd.h	117;"	d
OPT_A2STRVAL	pppd.h	118;"	d
OPT_ALIAS	pppd.h	109;"	d
OPT_DEVEQUIV	pppd.h	115;"	d
OPT_DEVNAM	pppd.h	116;"	d
OPT_ENABLE	pppd.h	111;"	d
OPT_HEX	pppd.h	93;"	d
OPT_HIDE	pppd.h	103;"	d
OPT_INC	pppd.h	96;"	d
OPT_INITONLY	pppd.h	114;"	d
OPT_LIMITS	pppd.h	101;"	d
OPT_LLIMIT	pppd.h	99;"	d
OPT_NOARG	pppd.h	94;"	d
OPT_NOINCR	pppd.h	105;"	d
OPT_NOPRINT	pppd.h	119;"	d
OPT_OR	pppd.h	95;"	d
OPT_PASSIVE	fsm.h	114;"	d
OPT_PRIO	pppd.h	107;"	d
OPT_PRIOSUB	pppd.h	108;"	d
OPT_PRIV	pppd.h	97;"	d
OPT_PRIVFIX	pppd.h	113;"	d
OPT_RESTART	fsm.h	115;"	d
OPT_SILENT	fsm.h	116;"	d
OPT_STATIC	pppd.h	98;"	d
OPT_ULIMIT	pppd.h	100;"	d
OPT_VAL	pppd.h	121;"	d
OPT_VALUE	pppd.h	92;"	d
OPT_ZEROINF	pppd.h	106;"	d
OPT_ZEROOK	pppd.h	102;"	d
OUTCHAR	utils.c	137;"	d	file:
O_NONBLOCK	main.c	184;"	d	file:
O_NONBLOCK	main.c	185;"	d	file:
O_NONBLOCK	main.old.c	184;"	d	file:
O_NONBLOCK	main.old.c	185;"	d	file:
PADDING	md5.c	/^static unsigned char PADDING[64] = {$/;"	v	file:
PAM_conv	auth.c	/^static int PAM_conv (int num_msg, const struct pam_message **msg,$/;"	f	file:
PAM_conversation	auth.c	/^static struct pam_conv PAM_conversation = {$/;"	v	file:
PAM_error	auth.c	/^static int PAM_error = 0;$/;"	v	file:
PAM_password	auth.c	/^static char *PAM_password;$/;"	v	file:
PAM_username	auth.c	/^static char *PAM_username;$/;"	v	file:
PAP_PEER	auth.c	167;"	d	file:
PAP_WITHPEER	auth.c	166;"	d	file:
PHASE_AUTHENTICATE	pppd.h	299;"	d
PHASE_CALLBACK	pppd.h	300;"	d
PHASE_DEAD	pppd.h	294;"	d
PHASE_DISCONNECT	pppd.h	304;"	d
PHASE_DORMANT	pppd.h	297;"	d
PHASE_ESTABLISH	pppd.h	298;"	d
PHASE_HOLDOFF	pppd.h	305;"	d
PHASE_INITIALIZE	pppd.h	295;"	d
PHASE_NETWORK	pppd.h	301;"	d
PHASE_RUNNING	pppd.h	302;"	d
PHASE_SERIALCONN	pppd.h	296;"	d
PHASE_TERMINATE	pppd.h	303;"	d
PIDSTRING	sys-sunos4.c	1388;"	d	file:
PLUGIN	Makefile	/^PLUGIN=y$/;"	m
PPPDOBJS	Makefile	/^PPPDOBJS = main.o magic.o fsm.o lcp.o ipcp.o upap.o chap.o md5.o ccp.o \\$/;"	m
PPPDSRCS	Makefile	/^PPPDSRCS = main.c magic.c fsm.c lcp.c ipcp.c upap.c chap.c md5.c ccp.c \\$/;"	m
PPP_DEV_NAME	sys-solaris.c	97;"	d	file:
PPP_DRV_NAME	main.c	222;"	d	file:
PPP_DRV_NAME	main.old.c	222;"	d	file:
PPP_DRV_NAME	sys-solaris.c	93;"	d	file:
PRINTMSG	pppd.h	662;"	d
PROTO_NAME	fsm.c	46;"	d	file:
PROTREJ	lcp.h	40;"	d
PUTCHAR	pppd.h	622;"	d
PUTLONG	pppd.h	642;"	d
PUTSHORT	pppd.h	631;"	d
PW_PPP	auth.c	64;"	d	file:
RACKTIMEOUT	ccp.c	187;"	d	file:
RACK_PENDING	ccp.c	184;"	d	file:
RCSID	auth.c	35;"	d	file:
RCSID	cbcp.c	21;"	d	file:
RCSID	ccp.c	28;"	d	file:
RCSID	chap.c	36;"	d	file:
RCSID	chap_ms.c	34;"	d	file:
RCSID	demand.c	20;"	d	file:
RCSID	eui64.c	21;"	d	file:
RCSID	fsm.c	20;"	d	file:
RCSID	ipcp.c	20;"	d	file:
RCSID	ipv6cp.c	96;"	d	file:
RCSID	ipxcp.c	22;"	d	file:
RCSID	lcp.c	20;"	d	file:
RCSID	magic.c	20;"	d	file:
RCSID	main.c	20;"	d	file:
RCSID	main.old.c	20;"	d	file:
RCSID	options.c	20;"	d	file:
RCSID	sys-solaris.c	45;"	d	file:
RCSID	sys-sunos4.c	28;"	d	file:
RCSID	tty.c	23;"	d	file:
RCSID	upap.c	20;"	d	file:
RCSID	utils.c	20;"	d	file:
REJCIADDR	ipcp.c	1098;"	d	file:
REJCICBCP	lcp.c	1339;"	d	file:
REJCICHAP	lcp.c	1297;"	d	file:
REJCICHARS	ipxcp.c	876;"	d	file:
REJCIDNS	ipcp.c	1143;"	d	file:
REJCIENDP	lcp.c	1352;"	d	file:
REJCIIFACEID	ipv6cp.c	778;"	d	file:
REJCILONG	lcp.c	1312;"	d	file:
REJCILQR	lcp.c	1325;"	d	file:
REJCINAME	ipxcp.c	898;"	d	file:
REJCINETWORK	ipxcp.c	861;"	d	file:
REJCINODE	ipxcp.c	897;"	d	file:
REJCIPROTO	ipxcp.c	913;"	d	file:
REJCISHORT	lcp.c	1284;"	d	file:
REJCIVJ	ipcp.c	1121;"	d	file:
REJCIVJ	ipv6cp.c	792;"	d	file:
REJCIVOID	ipxcp.c	900;"	d	file:
REJCIVOID	lcp.c	1275;"	d	file:
REQSENT	fsm.h	105;"	d
RIP_SAP	ipxcp.h	34;"	d
ROTATE_LEFT	md5.c	70;"	d	file:
ROUTE_MAX_COLS	sys-linux.c	1295;"	d	file:
RREQ_REPEAT	ccp.c	185;"	d	file:
S11	md5.c	209;"	d	file:
S12	md5.c	210;"	d	file:
S13	md5.c	211;"	d	file:
S14	md5.c	212;"	d	file:
S21	md5.c	231;"	d	file:
S22	md5.c	232;"	d	file:
S23	md5.c	233;"	d	file:
S24	md5.c	234;"	d	file:
S31	md5.c	253;"	d	file:
S32	md5.c	254;"	d	file:
S33	md5.c	255;"	d	file:
S34	md5.c	256;"	d	file:
S41	md5.c	275;"	d	file:
S42	md5.c	276;"	d	file:
S43	md5.c	277;"	d	file:
S44	md5.c	278;"	d	file:
SC_LOGB	sys-linux.c	474;"	d	file:
SC_RCVB	sys-linux.c	473;"	d	file:
SET_SA_FAMILY	sys-linux.c	194;"	d	file:
SIGNAL	main.c	654;"	d	file:
SIGNAL	main.old.c	654;"	d	file:
SIGTYPE	pppd.h	776;"	d
SIGTYPE	pppd.h	778;"	d
SIN_ADDR	sys-linux.c	168;"	d	file:
STANDALONE	tdb.h	1;"	d
STARTING	fsm.h	100;"	d
STOPPED	fsm.h	102;"	d
STOPPING	fsm.h	104;"	d
STRIP	Makefile	/^STRIP = $(CROSS)strip$/;"	m
SYSDEBUG	pppd.h	727;"	d
SYSDEBUG	pppd.h	729;"	d
StdText	chap_ms.c	/^static u_char *StdText = (u_char *)"KGS!@#$%"; \/* key from rasapi32.dll *\/$/;"	v	file:
TCP_HDRLEN	ipcp.c	2016;"	d	file:
TCP_HDRLEN	ipv6cp.c	1479;"	d	file:
TDB_ALIGN	tdb.c	34;"	d	file:
TDB_CLEAR_IF_FIRST	tdb.h	55;"	d
TDB_CONTEXT	tdb.h	/^} TDB_CONTEXT;$/;"	t
TDB_DATA	tdb.h	/^} TDB_DATA;$/;"	t
TDB_ERROR	tdb.h	/^enum TDB_ERROR {TDB_SUCCESS=0, TDB_ERR_CORRUPT, TDB_ERR_IO, TDB_ERR_LOCK, $/;"	g
TDB_ERR_CORRUPT	tdb.h	/^enum TDB_ERROR {TDB_SUCCESS=0, TDB_ERR_CORRUPT, TDB_ERR_IO, TDB_ERR_LOCK, $/;"	e	enum:TDB_ERROR
TDB_ERR_EXISTS	tdb.h	/^		TDB_ERR_OOM, TDB_ERR_EXISTS};$/;"	e	enum:TDB_ERROR
TDB_ERR_IO	tdb.h	/^enum TDB_ERROR {TDB_SUCCESS=0, TDB_ERR_CORRUPT, TDB_ERR_IO, TDB_ERR_LOCK, $/;"	e	enum:TDB_ERROR
TDB_ERR_LOCK	tdb.h	/^enum TDB_ERROR {TDB_SUCCESS=0, TDB_ERR_CORRUPT, TDB_ERR_IO, TDB_ERR_LOCK, $/;"	e	enum:TDB_ERROR
TDB_ERR_OOM	tdb.h	/^		TDB_ERR_OOM, TDB_ERR_EXISTS};$/;"	e	enum:TDB_ERROR
TDB_FREE_MAGIC	tdb.c	33;"	d	file:
TDB_INSERT	tdb.h	52;"	d
TDB_LEN_MULTIPLIER	tdb.c	38;"	d	file:
TDB_MAGIC	tdb.c	32;"	d	file:
TDB_MAGIC_FOOD	tdb.h	24;"	d
TDB_PAGE_SIZE	tdb.c	37;"	d	file:
TDB_REPLACE	tdb.h	51;"	d
TDB_SUCCESS	tdb.h	/^enum TDB_ERROR {TDB_SUCCESS=0, TDB_ERR_CORRUPT, TDB_ERR_IO, TDB_ERR_LOCK, $/;"	e	enum:TDB_ERROR
TDB_VERSION	tdb.c	31;"	d	file:
TERMACK	fsm.h	36;"	d
TERMREQ	fsm.h	35;"	d
TH_FIN	ipcp.c	2017;"	d	file:
TH_FIN	ipv6cp.c	1480;"	d	file:
TIMEOUT	pppd.h	656;"	d
TRUE	md4.c	34;"	d	file:
T_CURRENT	sys-solaris.c	2585;"	d	file:
Transform	md5.c	/^static void Transform (buf, in)$/;"	f	file:
UDP6_DEV_NAME	sys-solaris.c	121;"	d	file:
UDP_DEV_NAME	sys-solaris.c	117;"	d	file:
UINT4	md5.h	/^typedef unsigned int UINT4;$/;"	t
UL	md5.c	96;"	d	file:
UL	md5.c	98;"	d	file:
UNTIMEOUT	pppd.h	657;"	d
UPAPCS_AUTHREQ	upap.h	61;"	d
UPAPCS_BADAUTH	upap.h	63;"	d
UPAPCS_CLOSED	upap.h	59;"	d
UPAPCS_INITIAL	upap.h	58;"	d
UPAPCS_OPEN	upap.h	62;"	d
UPAPCS_PENDING	upap.h	60;"	d
UPAPDEBUG	pppd.h	757;"	d
UPAPDEBUG	pppd.h	759;"	d
UPAPSS_BADAUTH	upap.h	73;"	d
UPAPSS_CLOSED	upap.h	69;"	d
UPAPSS_INITIAL	upap.h	68;"	d
UPAPSS_LISTEN	upap.h	71;"	d
UPAPSS_OPEN	upap.h	72;"	d
UPAPSS_PENDING	upap.h	70;"	d
UPAP_AUTHACK	upap.h	32;"	d
UPAP_AUTHNAK	upap.h	33;"	d
UPAP_AUTHREQ	upap.h	31;"	d
UPAP_DEFREQTIME	upap.h	80;"	d
UPAP_DEFTIMEOUT	upap.h	79;"	d
UPAP_HEADERLEN	upap.h	25;"	d
USE_CRYPT	Makefile	/^USE_CRYPT=y$/;"	m
UseNT	chap_ms.c	/^    u_char UseNT;		\/* If 1, ignore the LANMan response field *\/$/;"	m	struct:	file:
VALIDID	ipv6cp.c	286;"	d	file:
VERSION	patchlevel.h	3;"	d
WTMPFILE	sys-sunos4.c	1258;"	d	file:
_IN6_LLX_FROM_EUI64	sys-solaris.c	147;"	d	file:
_PATH_AUTHDOWN	pathnames.h	27;"	d
_PATH_AUTHUP	pathnames.h	26;"	d
_PATH_CHAPFILE	pathnames.h	22;"	d
_PATH_CONNERRS	pathnames.h	29;"	d
_PATH_DEVNULL	pathnames.h	14;"	d
_PATH_IPDOWN	pathnames.h	25;"	d
_PATH_IPUP	pathnames.h	24;"	d
_PATH_IPV6DOWN	pathnames.h	37;"	d
_PATH_IPV6UP	pathnames.h	36;"	d
_PATH_IPXDOWN	pathnames.h	42;"	d
_PATH_IPXUP	pathnames.h	41;"	d
_PATH_PEERFILES	pathnames.h	30;"	d
_PATH_PLUGIN	pathnames.h	56;"	d
_PATH_PPPDB	pathnames.h	46;"	d
_PATH_PPPDB	pathnames.h	49;"	d
_PATH_PPPDB	pathnames.h	51;"	d
_PATH_RESOLV	pathnames.h	31;"	d
_PATH_SYSOPTIONS	pathnames.h	23;"	d
_PATH_TTYOPT	pathnames.h	28;"	d
_PATH_UPAPFILE	pathnames.h	21;"	d
_PATH_USEROPT	pathnames.h	33;"	d
_PATH_VARRUN	pathnames.h	12;"	d
_ROOT_PATH	pathnames.h	18;"	d
__CHAPMS_INCLUDE__	chap_ms.h	32;"	d
__CHAP_INCLUDE__	chap.h	123;"	d
__EUI64_H__	eui64.h	22;"	d
__MD5_INCLUDE__	md5.h	57;"	d
__P	md4.h	13;"	d
__P	md4.h	15;"	d
__PPPD_H__	pppd.h	27;"	d
__V	pppd.h	39;"	d
__V	pppd.h	42;"	d
accept_local	ipcp.h	/^    bool accept_local;		\/* accept peer's value for ouraddr *\/$/;"	m	struct:ipcp_options
accept_local	ipv6cp.h	/^    int accept_local;		\/* accept peer's value for iface id? *\/$/;"	m	struct:ipv6cp_options
accept_local	ipxcp.h	/^    bool accept_local;		\/* accept peer's value for ournode *\/$/;"	m	struct:ipxcp_options
accept_network	ipxcp.h	/^    bool accept_network;	\/* accept network number *\/$/;"	m	struct:ipxcp_options
accept_remote	ipcp.h	/^    bool accept_remote;		\/* accept peer's value for hisaddr *\/$/;"	m	struct:ipcp_options
accept_remote	ipxcp.h	/^    bool accept_remote;		\/* accept peer's value for hisnode *\/$/;"	m	struct:ipxcp_options
ackci	fsm.h	/^    int  (*ackci)		\/* ACK our Configuration Information *\/$/;"	m	struct:fsm_callbacks
active_filter	options.c	/^struct	bpf_program active_filter; \/* Filter program for link-active pkts *\/$/;"	v
active_packet	demand.c	/^active_packet(p, len)$/;"	f	file:
active_pkt	pppd.h	/^    int  (*active_pkt) __P((u_char *pkt, int len));$/;"	m	struct:protent
add_db_key	main.c	/^add_db_key(str)$/;"	f	file:
add_db_key	main.old.c	/^add_db_key(str)$/;"	f	file:
add_fd	sys-linux.c	/^void add_fd(int fd)$/;"	f
add_fd	sys-solaris.c	/^void add_fd(fd)$/;"	f
add_fd	sys-sunos4.c	/^void add_fd(fd)$/;"	f
add_notifier	main.c	/^add_notifier(notif, func, arg)$/;"	f
add_notifier	main.old.c	/^add_notifier(notif, func, arg)$/;"	f
add_options	options.c	/^add_options(opt)$/;"	f
addci	fsm.h	/^    void (*addci) 		\/* Add our Configuration Information *\/$/;"	m	struct:fsm_callbacks
addr	pppd.h	/^	void	*addr;$/;"	m	struct:
addr2	pppd.h	/^	void	*addr2;$/;"	m	struct:
addresses	auth.c	/^static struct permitted_ip *addresses[NUM_PPP];$/;"	v	file:
all_rejected	ccp.c	/^static int all_rejected[NUM_PPP];	\/* we rejected all peer's options *\/$/;"	v	file:
allow_any_ip	auth.c	/^bool allow_any_ip = 0;		\/* Allow peer to use any IP address *\/$/;"	v
any_compressions	sys-solaris.c	/^any_compressions()$/;"	f	file:
ao	ipxcp.c	51;"	d	file:
arg	main.c	/^    void	*arg;$/;"	m	struct:subprocess	file:
arg	main.old.c	/^    void	*arg;$/;"	m	struct:subprocess	file:
arg	pppd.h	/^    void	    *arg;$/;"	m	struct:notifier
ask_for_local	ipcp.c	/^static bool ask_for_local;		\/* request our address from peer *\/$/;"	v	file:
asyncmap	lcp.h	/^    u_int32_t asyncmap;		\/* Value of async map *\/$/;"	m	struct:lcp_options
auth_check_options	auth.c	/^auth_check_options()$/;"	f
auth_ip_addr	auth.c	/^auth_ip_addr(unit, addr)$/;"	f
auth_options	auth.c	/^option_t auth_options[] = {$/;"	v
auth_peer_fail	auth.c	/^auth_peer_fail(unit, protocol)$/;"	f
auth_peer_success	auth.c	/^auth_peer_success(unit, protocol, name, namelen)$/;"	f
auth_pending	auth.c	/^static int auth_pending[NUM_PPP];$/;"	v	file:
auth_required	auth.c	/^bool auth_required = 0;		\/* Always require authentication from peer *\/$/;"	v
auth_reset	auth.c	/^auth_reset(unit)$/;"	f
auth_script	auth.c	/^auth_script(script)$/;"	f	file:
auth_script_done	auth.c	/^auth_script_done(arg)$/;"	f	file:
auth_script_pid	auth.c	/^static pid_t auth_script_pid = 0;$/;"	v	file:
auth_script_state	auth.c	/^static enum script_state auth_script_state = s_down;$/;"	v	file:
auth_state	auth.c	/^static enum script_state auth_state = s_down;$/;"	v	file:
auth_withpeer_fail	auth.c	/^auth_withpeer_fail(unit, protocol)$/;"	f
auth_withpeer_success	auth.c	/^auth_withpeer_success(unit, protocol)$/;"	f
bad_ip_adrs	auth.c	/^bad_ip_adrs(addr)$/;"	f
bad_signal	main.c	/^bad_signal(sig)$/;"	f	file:
bad_signal	main.old.c	/^bad_signal(sig)$/;"	f	file:
base	pppd.h	/^    u_int32_t	base;		\/* match if (addr & mask) == base *\/$/;"	m	struct:permitted_ip
baud_rate	tty.c	/^int baud_rate;			\/* Actual bits\/second for serial device *\/$/;"	v
baud_rate_of	sys-linux.c	/^static int baud_rate_of (int speed)$/;"	f	file:
baud_rate_of	sys-solaris.c	/^baud_rate_of(speed)$/;"	f	file:
baud_rate_of	sys-sunos4.c	/^baud_rate_of(speed)$/;"	f	file:
bool	pppd.h	/^typedef unsigned char	bool;$/;"	t
bsd_bits	ccp.h	/^    u_short bsd_bits;		\/* # bits\/code for BSD Compress *\/$/;"	m	struct:ccp_options
bsd_compress	ccp.h	/^    bool bsd_compress;		\/* do BSD Compress? *\/$/;"	m	struct:ccp_options
bsd_value	ccp.c	/^static char bsd_value[8];$/;"	v	file:
buf	md5.h	/^  UINT4 buf[4];                                    \/* scratch buffer *\/$/;"	m	struct:
buffer	md4.h	/^	unsigned int buffer[4]; \/* Holds 4-word result of MD computation *\/$/;"	m	struct:
buffer_info	utils.c	/^struct buffer_info {$/;"	s	file:
bundle_attach	sys-linux.c	/^int bundle_attach(int ifnum)$/;"	f
bundle_id	multilink.c	/^char *bundle_id;		\/* identifier for our bundle *\/$/;"	v
bundle_name	options.c	/^char	*bundle_name = NULL;	\/* bundle name for multilink *\/$/;"	v
bytes_in	pppd.h	/^    unsigned int	bytes_in;$/;"	m	struct:pppd_stats
bytes_out	pppd.h	/^    unsigned int	bytes_out;$/;"	m	struct:pppd_stats
c_arg	main.c	/^    void		*c_arg;		\/* argument to routine *\/$/;"	m	struct:callout	file:
c_arg	main.old.c	/^    void		*c_arg;		\/* argument to routine *\/$/;"	m	struct:callout	file:
c_func	main.c	/^    void		(*c_func) __P((void *)); \/* routine *\/$/;"	m	struct:callout	file:
c_func	main.old.c	/^    void		(*c_func) __P((void *)); \/* routine *\/$/;"	m	struct:callout	file:
c_next	main.c	/^    struct		callout *c_next;$/;"	m	struct:callout	file:
c_next	main.old.c	/^    struct		callout *c_next;$/;"	m	struct:callout	file:
c_time	main.c	/^    struct timeval	c_time;		\/* time at which to call routine *\/$/;"	m	struct:callout	file:
c_time	main.old.c	/^    struct timeval	c_time;		\/* time at which to call routine *\/$/;"	m	struct:callout	file:
callback_script	tty.c	/^char *callback_script;		\/* script for doing callback *\/$/;"	v
callbacks	fsm.h	/^    struct fsm_callbacks *callbacks;	\/* Callback routines *\/$/;"	m	struct:fsm
callfile	options.c	/^callfile(argv)$/;"	f	file:
callout	main.c	/^static struct callout *callout = NULL;	\/* Callout list *\/$/;"	v	file:
callout	main.c	/^struct	callout {$/;"	s	file:
callout	main.old.c	/^static struct callout *callout = NULL;	\/* Callout list *\/$/;"	v	file:
callout	main.old.c	/^struct	callout {$/;"	s	file:
calltimeout	main.c	/^calltimeout()$/;"	f	file:
calltimeout	main.old.c	/^calltimeout()$/;"	f	file:
cbcp	cbcp.c	/^cbcp_state cbcp[NUM_PPP];	$/;"	v
cbcp_codenames	cbcp.c	/^char *cbcp_codenames[] = {$/;"	v
cbcp_init	cbcp.c	/^cbcp_init(iface)$/;"	f	file:
cbcp_input	cbcp.c	/^cbcp_input(unit, inpacket, pktlen)$/;"	f	file:
cbcp_lowerup	cbcp.c	/^cbcp_lowerup(iface)$/;"	f	file:
cbcp_open	cbcp.c	/^cbcp_open(unit)$/;"	f	file:
cbcp_option_list	cbcp.c	/^static option_t cbcp_option_list[] = {$/;"	v	file:
cbcp_optionnames	cbcp.c	/^char *cbcp_optionnames[] = {$/;"	v
cbcp_printpkt	cbcp.c	/^cbcp_printpkt(p, plen, printer, arg)$/;"	f	file:
cbcp_protent	cbcp.c	/^struct protent cbcp_protent = {$/;"	v
cbcp_protrej	cbcp.c	/^void cbcp_protrej(int iface)$/;"	f
cbcp_recvack	cbcp.c	/^cbcp_recvack(us, pckt, len)$/;"	f	file:
cbcp_recvreq	cbcp.c	/^cbcp_recvreq(us, pckt, pcktlen)$/;"	f	file:
cbcp_resp	cbcp.c	/^cbcp_resp(us)$/;"	f	file:
cbcp_send	cbcp.c	/^cbcp_send(us, code, buf, len)$/;"	f	file:
cbcp_state	cbcp.h	/^typedef struct cbcp_state {$/;"	s
cbcp_state	cbcp.h	/^} cbcp_state;$/;"	t
cbcp_up	cbcp.c	/^cbcp_up(us)$/;"	f	file:
ccp_ackci	ccp.c	/^ccp_ackci(f, p, len)$/;"	f	file:
ccp_addci	ccp.c	/^ccp_addci(f, p, lenp)$/;"	f	file:
ccp_allowoptions	ccp.c	/^ccp_options ccp_allowoptions[NUM_PPP];	\/* what we'll agree to do *\/$/;"	v
ccp_callbacks	ccp.c	/^static fsm_callbacks ccp_callbacks = {$/;"	v	file:
ccp_cilen	ccp.c	/^ccp_cilen(f)$/;"	f	file:
ccp_close	ccp.c	/^ccp_close(unit, reason)$/;"	f	file:
ccp_codenames	ccp.c	/^static char *ccp_codenames[] = {$/;"	v	file:
ccp_datainput	ccp.c	/^ccp_datainput(unit, pkt, len)$/;"	f	file:
ccp_down	ccp.c	/^ccp_down(f)$/;"	f	file:
ccp_extcode	ccp.c	/^ccp_extcode(f, code, id, p, len)$/;"	f	file:
ccp_fatal_error	sys-linux.c	/^int ccp_fatal_error (int unit)$/;"	f
ccp_fatal_error	sys-solaris.c	/^ccp_fatal_error(unit)$/;"	f
ccp_fatal_error	sys-sunos4.c	/^ccp_fatal_error(unit)$/;"	f
ccp_flags_set	sys-linux.c	/^void ccp_flags_set (int unit, int isopen, int isup)$/;"	f
ccp_flags_set	sys-solaris.c	/^ccp_flags_set(unit, isopen, isup)$/;"	f
ccp_flags_set	sys-sunos4.c	/^ccp_flags_set(unit, isopen, isup)$/;"	f
ccp_fsm	ccp.c	/^fsm ccp_fsm[NUM_PPP];$/;"	v
ccp_gotoptions	ccp.c	/^ccp_options ccp_gotoptions[NUM_PPP];	\/* what the peer agreed to do *\/$/;"	v
ccp_hisoptions	ccp.c	/^ccp_options ccp_hisoptions[NUM_PPP];	\/* what we agreed to do *\/$/;"	v
ccp_init	ccp.c	/^ccp_init(unit)$/;"	f	file:
ccp_input	ccp.c	/^ccp_input(unit, p, len)$/;"	f	file:
ccp_localstate	ccp.c	/^static int ccp_localstate[NUM_PPP];$/;"	v	file:
ccp_lowerdown	ccp.c	/^ccp_lowerdown(unit)$/;"	f	file:
ccp_lowerup	ccp.c	/^ccp_lowerup(unit)$/;"	f	file:
ccp_nakci	ccp.c	/^ccp_nakci(f, p, len)$/;"	f	file:
ccp_open	ccp.c	/^ccp_open(unit)$/;"	f	file:
ccp_option_list	ccp.c	/^static option_t ccp_option_list[] = {$/;"	v	file:
ccp_options	ccp.h	/^typedef struct ccp_options {$/;"	s
ccp_options	ccp.h	/^} ccp_options;$/;"	t
ccp_printpkt	ccp.c	/^ccp_printpkt(p, plen, printer, arg)$/;"	f	file:
ccp_protent	ccp.c	/^struct protent ccp_protent = {$/;"	v
ccp_protrej	ccp.c	/^ccp_protrej(unit)$/;"	f	file:
ccp_rack_timeout	ccp.c	/^ccp_rack_timeout(arg)$/;"	f	file:
ccp_rejci	ccp.c	/^ccp_rejci(f, p, len)$/;"	f	file:
ccp_reqci	ccp.c	/^ccp_reqci(f, p, lenp, dont_nak)$/;"	f	file:
ccp_resetci	ccp.c	/^ccp_resetci(f)$/;"	f	file:
ccp_test	sys-linux.c	/^int ccp_test (int unit, u_char *opt_ptr, int opt_len, int for_transmit)$/;"	f
ccp_test	sys-solaris.c	/^ccp_test(unit, opt_ptr, opt_len, for_transmit)$/;"	f
ccp_test	sys-sunos4.c	/^ccp_test(unit, opt_ptr, opt_len, for_transmit)$/;"	f
ccp_up	ccp.c	/^ccp_up(f)$/;"	f	file:
ccp_wantoptions	ccp.c	/^ccp_options ccp_wantoptions[NUM_PPP];	\/* what to request the peer to use *\/$/;"	v
cfg_bundle	sys-linux.c	/^void cfg_bundle(int mrru, int mtru, int rssn, int tssn)$/;"	f
cflag	ipcp.h	/^    bool cflag;$/;"	m	struct:ipcp_options
chal_id	chap.h	/^    u_char chal_id;		\/* ID of last challenge *\/$/;"	m	struct:chap_state
chal_interval	chap.h	/^    int chal_interval;		\/* Time until we challenge peer again *\/$/;"	m	struct:chap_state
chal_len	chap.h	/^    u_char chal_len;		\/* challenge length *\/$/;"	m	struct:chap_state
chal_name	chap.h	/^    char *chal_name;		\/* Our name to use with challenge *\/$/;"	m	struct:chap_state
chal_transmits	chap.h	/^    int chal_transmits;		\/* Number of transmissions of challenge *\/$/;"	m	struct:chap_state
chal_type	chap.h	/^    u_char chal_type;		\/* hash algorithm for challenges *\/$/;"	m	struct:chap_state
challenge	chap.h	/^    u_char challenge[MAX_CHALLENGE_LENGTH]; \/* last challenge string sent *\/$/;"	m	struct:chap_state
channel	pppd.h	/^struct channel {$/;"	s
chap	chap.c	/^chap_state chap[NUM_PPP];		\/* CHAP state; one for each unit *\/$/;"	v
chap_mdtype	lcp.h	/^    u_char chap_mdtype;		\/* which MD type (hashing algorithm) *\/$/;"	m	struct:lcp_options
chap_option_list	chap.c	/^static option_t chap_option_list[] = {$/;"	v	file:
chap_protent	chap.c	/^struct protent chap_protent = {$/;"	v
chap_state	chap.h	/^typedef struct chap_state {$/;"	s
chap_state	chap.h	/^} chap_state;$/;"	t
charshunt	tty.c	/^charshunt(ifd, ofd, record_file)$/;"	f	file:
charshunt_done	tty.c	/^charshunt_done(arg)$/;"	f	file:
charshunt_pid	tty.c	/^int charshunt_pid;		\/* Process ID for charshunt *\/$/;"	v
check_access	auth.c	/^check_access(f, filename)$/;"	f	file:
check_idle	auth.c	/^check_idle(arg)$/;"	f	file:
check_options	options.c	/^check_options()$/;"	f
check_options	pppd.h	/^	void (*check_options) __P((void));$/;"	m	struct:channel
check_options	pppd.h	/^    void (*check_options) __P((void));$/;"	m	struct:protent
check_passwd	auth.c	/^check_passwd(unit, auser, userlen, apasswd, passwdlen, msg)$/;"	f
children	main.c	/^static struct subprocess *children;$/;"	v	file:
children	main.old.c	/^static struct subprocess *children;$/;"	v	file:
chindex	sys-linux.c	/^static int chindex;		\/* channel index (new style driver) *\/$/;"	v	file:
chld	main.c	/^chld(sig)$/;"	f	file:
chld	main.old.c	/^chld(sig)$/;"	f	file:
cif6addr	sys-linux.c	/^int cif6addr (int unit, eui64_t our_eui64, eui64_t his_eui64)$/;"	f
cif6addr	sys-solaris.c	/^cif6addr(u, o, h)$/;"	f
cifaddr	sys-linux.c	/^int cifaddr (int unit, u_int32_t our_adr, u_int32_t his_adr)$/;"	f
cifaddr	sys-solaris.c	/^cifaddr(u, o, h)$/;"	f
cifaddr	sys-sunos4.c	/^cifaddr(u, o, h)$/;"	f
cifdefaultroute	sys-linux.c	/^int cifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway)$/;"	f
cifdefaultroute	sys-solaris.c	/^cifdefaultroute(u, l, g)$/;"	f
cifdefaultroute	sys-sunos4.c	/^cifdefaultroute(u, l, g)$/;"	f
cifproxyarp	sys-linux.c	/^int cifproxyarp (int unit, u_int32_t his_adr)$/;"	f
cifproxyarp	sys-solaris.c	/^cifproxyarp(unit, hisaddr)$/;"	f
cifproxyarp	sys-sunos4.c	/^cifproxyarp(unit, hisaddr)$/;"	f
cifroute	sys-solaris.c	/^cifroute(u, our, his)$/;"	f
cilen	fsm.h	/^    int  (*cilen)		\/* Length of our Configuration Information *\/$/;"	m	struct:fsm_callbacks
cipxfaddr	sys-linux.c	/^int cipxfaddr (int unit)$/;"	f
clean_check	sys-linux.c	/^void clean_check(void)$/;"	f
clean_check	sys-solaris.c	/^clean_check()$/;"	f
clean_check	sys-sunos4.c	/^clean_check()$/;"	f
cleanup	main.c	/^cleanup()$/;"	f	file:
cleanup	main.old.c	/^cleanup()$/;"	f	file:
cleanup	pppd.h	/^	void (*cleanup) __P((void));$/;"	m	struct:channel
cleanup_db	main.c	/^cleanup_db()$/;"	f	file:
cleanup_db	main.old.c	/^cleanup_db()$/;"	f	file:
cleanup_tty	tty.c	/^void cleanup_tty()$/;"	f
clientstate	chap.h	/^    int clientstate;		\/* Client state *\/$/;"	m	struct:chap_state
close	pppd.h	/^	void (*close) __P((void));$/;"	m	struct:channel
close	pppd.h	/^    void (*close) __P((int unit, char *reason));$/;"	m	struct:protent
close_route_table	sys-linux.c	/^static void close_route_table (void)$/;"	f	file:
compare_node	ipxcp.c	/^compare_node (src, dst)$/;"	f	file:
conn_running	main.c	/^static int conn_running;	\/* we have a [dis]connector running *\/$/;"	v	file:
conn_running	main.old.c	/^static int conn_running;	\/* we have a [dis]connector running *\/$/;"	v	file:
connect	pppd.h	/^	int  (*connect) __P((void));$/;"	m	struct:channel
connect_delay	options.c	/^int	connect_delay = 1000;	\/* wait this many ms after connect script *\/$/;"	v
connect_script	tty.c	/^char	*connect_script = NULL;	\/* Script to establish physical link *\/$/;"	v
connect_time_expired	auth.c	/^connect_time_expired(arg)$/;"	f	file:
connect_tty	tty.c	/^int connect_tty()$/;"	f
const	pppd.h	43;"	d
copy_node	ipxcp.c	/^copy_node (src, dst)$/;"	f	file:
count	md4.h	/^	unsigned char count[8]; \/* Number of bits processed so far *\/$/;"	m	struct:
create_linkpidfile	main.c	/^create_linkpidfile()$/;"	f	file:
create_linkpidfile	main.old.c	/^create_linkpidfile()$/;"	f	file:
create_pidfile	main.c	/^create_pidfile()$/;"	f	file:
create_pidfile	main.old.c	/^create_pidfile()$/;"	f	file:
create_resolv	ipcp.c	/^create_resolv(peerdns1, peerdns2)$/;"	f	file:
crtscts	tty.c	/^int	crtscts = 0;		\/* Use hardware flow control *\/$/;"	v
cryptpap	auth.c	/^bool cryptpap = 0;		\/* Passwords in pap-secrets are encrypted *\/$/;"	v
current_option	options.c	/^char *current_option;		\/* the name of the option being parsed *\/$/;"	v
data	demand.c	/^    unsigned char data[1];$/;"	m	struct:packet	file:
data_len	tdb.c	/^	tdb_len data_len; \/* byte length of data *\/$/;"	m	struct:list_struct	file:
data_name	pppd.h	/^    char *data_name;		\/* Text name of corresponding data protocol *\/$/;"	m	struct:protent
datainput	pppd.h	/^    void (*datainput) __P((int unit, u_char *pkt, int len));$/;"	m	struct:protent
db_key	main.c	/^char db_key[32];$/;"	v
db_key	main.old.c	/^char db_key[32];$/;"	v
dbglog	utils.c	/^dbglog __V((char *fmt, ...))$/;"	f
debug	options.c	/^int	debug = 0;		\/* Debug flag *\/$/;"	v
decode_version	sys-linux.c	/^static void decode_version (char *buf, int *version,$/;"	f	file:
default_auth	auth.c	/^static bool default_auth;$/;"	v	file:
default_device	options.c	/^int	default_device = 1;	\/* Using \/dev\/tty or equivalent *\/$/;"	v
default_route	ipcp.h	/^    bool default_route;		\/* Assign default route through interface? *\/$/;"	m	struct:ipcp_options
default_route_gateway	sys-linux.c	/^static u_int32_t default_route_gateway;	\/* Gateway for default route added *\/$/;"	v	file:
default_route_gateway	sys-solaris.c	/^static u_int32_t default_route_gateway;	\/* Gateway for default route added *\/$/;"	v	file:
default_route_gateway	sys-sunos4.c	/^static u_int32_t default_route_gateway;	\/* Gateway for default route added *\/$/;"	v	file:
default_route_set	ipcp.c	/^static int default_route_set[NUM_PPP];	\/* Have set up a default route *\/$/;"	v	file:
defaultroute_exists	sys-linux.c	/^static int defaultroute_exists (struct rtentry *rt)$/;"	f	file:
deflate	ccp.h	/^    bool deflate;		\/* do Deflate? *\/$/;"	m	struct:ccp_options
deflate_correct	ccp.h	/^    bool deflate_correct;	\/* use correct code for deflate? *\/$/;"	m	struct:ccp_options
deflate_draft	ccp.h	/^    bool deflate_draft;		\/* use draft RFC code for deflate? *\/$/;"	m	struct:ccp_options
deflate_size	ccp.h	/^    u_short deflate_size;	\/* lg(window size) for Deflate *\/$/;"	m	struct:ccp_options
deflate_value	ccp.c	/^static char deflate_value[8];$/;"	v	file:
delete_db_key	main.c	/^delete_db_key(str)$/;"	f	file:
delete_db_key	main.old.c	/^delete_db_key(str)$/;"	f	file:
demand	options.c	/^bool	demand = 0;		\/* do dial-on-demand *\/$/;"	v
demand_block	demand.c	/^demand_block()$/;"	f
demand_conf	demand.c	/^demand_conf()$/;"	f
demand_conf	pppd.h	/^    int  (*demand_conf) __P((int unit));$/;"	m	struct:protent
demand_discard	demand.c	/^demand_discard()$/;"	f
demand_rexmit	demand.c	/^demand_rexmit(proto)$/;"	f
demand_unblock	demand.c	/^demand_unblock()$/;"	f
description	pppd.h	/^	char	*description;$/;"	m	struct:
detach	main.c	/^detach()$/;"	f
detach	main.old.c	/^detach()$/;"	f
detached	main.c	/^int detached;			\/* have detached from terminal *\/$/;"	v
detached	main.old.c	/^int detached;			\/* have detached from terminal *\/$/;"	v
devfd	main.c	/^static int devfd;		\/* fd of underlying device *\/$/;"	v	file:
devfd	main.old.c	/^static int devfd;		\/* fd of underlying device *\/$/;"	v	file:
device_script	main.c	/^device_script(program, in, out, dont_wait)$/;"	f
device_script	main.old.c	/^device_script(program, in, out, dont_wait)$/;"	f
devnam	options.c	/^char	devnam[MAXPATHLEN];	\/* Device name *\/$/;"	v
devnam_fixed	options.c	/^bool devnam_fixed;		\/* can no longer change device name *\/$/;"	v
devstat	tty.c	/^struct stat devstat;		\/* result of stat() on devnam *\/$/;"	v
dflag	options.c	/^int	dflag = 0;		\/* Tell libpcap we want debugging *\/$/;"	v
die	main.c	/^die(status)$/;"	f
die	main.old.c	/^die(status)$/;"	f
digest	md5.h	/^  unsigned char digest[16];     \/* actual digest after MD5Final call *\/$/;"	m	struct:
disable_defaultip	ipcp.c	/^bool	disable_defaultip = 0;	\/* Don't use hostname for default IP adrs *\/$/;"	v
disconnect	pppd.h	/^	void (*disconnect) __P((void));$/;"	m	struct:channel
disconnect_script	tty.c	/^char	*disconnect_script = NULL; \/* Script to disestablish physical link *\/$/;"	v
disconnect_tty	tty.c	/^void disconnect_tty()$/;"	f
disestablish_ppp	pppd.h	/^	void (*disestablish_ppp) __P((int));$/;"	m	struct:channel
dlpi_attach	sys-solaris.c	/^dlpi_attach(fd, ppa)$/;"	f	file:
dlpi_get_reply	sys-solaris.c	/^dlpi_get_reply(fd, reply, expected_prim, maxlen)$/;"	f	file:
dlpi_info_req	sys-solaris.c	/^dlpi_info_req(fd)$/;"	f	file:
dnsaddr	ipcp.h	/^    u_int32_t dnsaddr[2];	\/* Primary and secondary MS DNS entries *\/$/;"	m	struct:ipcp_options
do_callback	main.c	/^int do_callback;		\/* != 0 if we should do callback next *\/$/;"	v
do_callback	main.old.c	/^int do_callback;		\/* != 0 if we should do callback next *\/$/;"	v
doing_callback	main.c	/^int doing_callback;		\/* != 0 if we are doing callback *\/$/;"	v
doing_callback	main.old.c	/^int doing_callback;		\/* != 0 if we are doing callback *\/$/;"	v
domain	options.c	/^char	*domain;		\/* domain name set by domain option *\/$/;"	v
done	main.c	/^    void	(*done) __P((void *));$/;"	m	struct:subprocess	file:
done	main.old.c	/^    void	(*done) __P((void *));$/;"	m	struct:subprocess	file:
done	md4.h	/^	unsigned int done;      \/* Nonzero means MD computation finished *\/$/;"	m	struct:
down	fsm.h	/^    void (*down)		\/* Called when fsm leaves OPENED state *\/$/;"	m	struct:fsm_callbacks
dptr	tdb.h	/^	char *dptr;$/;"	m	struct:
drand48	magic.c	/^drand48()$/;"	f
driver_is_old	sys-linux.c	/^static int driver_is_old       = 0;$/;"	v	file:
driver_modification	sys-linux.c	/^static int driver_modification = 0;$/;"	v	file:
driver_patch	sys-linux.c	/^static int driver_patch        = 0;$/;"	v	file:
driver_version	sys-linux.c	/^static int driver_version      = 0;$/;"	v	file:
dryrun	options.c	/^bool	dryrun;			\/* print out option values and exit *\/$/;"	v
dsize	tdb.h	/^	size_t dsize;$/;"	m	struct:
dump_options	options.c	/^bool	dump_options;		\/* print out option values *\/$/;"	v
dynaddr_set	sys-linux.c	/^static int	dynaddr_set;		\/* 1 if ip_dynaddr set *\/$/;"	v	file:
e16	eui64.h	/^    u_int16_t e16[4];$/;"	m	union:
e32	eui64.h	/^    u_int32_t e32[2];$/;"	m	union:
e32	eui64.h	/^    uint32_t	e32[2];		\/* lower 64-bit IPv6 address *\/$/;"	m	union:
e8	eui64.h	/^    u_int8_t e8[8];$/;"	m	union:
e8	eui64.h	/^    uint8_t	e8[8];		\/* lower 64-bit IPv6 address *\/$/;"	m	union:
ecode	tdb.h	/^	int ecode; \/* error code for last tdb error *\/$/;"	m	struct:
enabled_flag	pppd.h	/^    bool enabled_flag;		\/* 0 iff protocol is disabled *\/$/;"	m	struct:protent
end_pr_log	utils.c	/^end_pr_log()$/;"	f
endp_class_names	multilink.c	/^static char *endp_class_names[] = {$/;"	v	file:
endpoint	lcp.h	/^    struct epdisc endpoint;	\/* endpoint discriminator *\/$/;"	m	struct:lcp_options
endpoint_specified	multilink.c	/^bool endpoint_specified;	\/* user gave explicit endpoint discriminator *\/$/;"	v
epdisc	pppd.h	/^struct epdisc {$/;"	s
epdisc_to_str	multilink.c	/^epdisc_to_str(ep)$/;"	f
error	utils.c	/^error __V((char *fmt, ...))$/;"	f
escape_flag	demand.c	/^int escape_flag;$/;"	v
establish_ppp	pppd.h	/^	int  (*establish_ppp) __P((int));$/;"	m	struct:channel
ether_to_eui64	sys-solaris.c	/^ether_to_eui64(eui64_t *p_eui64)$/;"	f
eui64_copy	eui64.h	64;"	d
eui64_equals	eui64.h	60;"	d
eui64_get	eui64.h	78;"	d
eui64_iszero	eui64.h	59;"	d
eui64_magic	eui64.h	66;"	d
eui64_magic_ne	eui64.h	74;"	d
eui64_magic_nz	eui64.h	71;"	d
eui64_ntoa	eui64.c	/^eui64_ntoa(e)$/;"	f
eui64_put	eui64.h	83;"	d
eui64_set32	eui64.h	88;"	d
eui64_setlo32	eui64.h	92;"	d
eui64_t	eui64.h	/^} eui64_t;$/;"	t
eui64_zero	eui64.h	62;"	d
exitnotify	main.c	/^struct notifier *exitnotify = NULL;$/;"	v
exitnotify	main.old.c	/^struct notifier *exitnotify = NULL;$/;"	v
explicit_remote	auth.c	/^bool explicit_remote = 0;	\/* User specified explicit remote name *\/$/;"	v
extcode	fsm.h	/^    int  (*extcode)		\/* Called when unknown code received *\/$/;"	m	struct:fsm_callbacks
extra_options	auth.c	/^static struct wordlist *extra_options;$/;"	v	file:
extra_options	options.c	/^static struct option_list *extra_options = NULL;$/;"	v	file:
f	md4.c	74;"	d	file:
fatal	utils.c	/^fatal __V((char *fmt, ...))$/;"	f
fcs	demand.c	/^int fcs;$/;"	v
fcstab	demand.c	/^static u_short fcstab[256] = {$/;"	v	file:
fd	tdb.h	/^	int fd; \/* open file descriptor for the database *\/$/;"	m	struct:
fd_loop	main.c	/^static int fd_loop;		\/* fd for getting demand-dial packets *\/$/;"	v	file:
fd_loop	main.old.c	/^static int fd_loop;		\/* fd for getting demand-dial packets *\/$/;"	v	file:
fd_ppp	main.c	/^static int fd_ppp = -1;		\/* fd for talking PPP *\/$/;"	v	file:
fd_ppp	main.old.c	/^static int fd_ppp = -1;		\/* fd for talking PPP *\/$/;"	v	file:
fdmuxid	sys-solaris.c	/^static int	fdmuxid = -1;$/;"	v	file:
fdmuxid	sys-sunos4.c	/^static int	fdmuxid = -1;$/;"	v	file:
ff	md4.c	78;"	d	file:
find_option	options.c	/^find_option(name)$/;"	f	file:
finish_tty	tty.c	/^finish_tty()$/;"	f	file:
finished	fsm.h	/^    void (*finished)		\/* Called when we don't want the lower layer *\/$/;"	m	struct:fsm_callbacks
first_ether_name	sys-solaris.c	/^static char	first_ether_name[IFNAMSIZ];	\/* Before Solaris 8 *\/$/;"	v	file:
first_ether_name	sys-solaris.c	/^static char	first_ether_name[LIFNAMSIZ];	\/* Solaris 8 and above *\/$/;"	v	file:
flags	fsm.h	/^    int flags;			\/* Contains option bits *\/$/;"	m	struct:fsm
flags	pppd.h	/^	int	flags;$/;"	m	struct:
flush_flag	demand.c	/^int flush_flag;$/;"	v
format_packet	utils.c	/^format_packet(p, len, printer, arg)$/;"	f	file:
frame	demand.c	/^char *frame;$/;"	v
framelen	demand.c	/^int framelen;$/;"	v
framemax	demand.c	/^int framemax;$/;"	v
free_wordlist	auth.c	/^free_wordlist(wp)$/;"	f	file:
fs1	md4.c	56;"	d	file:
fs2	md4.c	57;"	d	file:
fs3	md4.c	58;"	d	file:
fs4	md4.c	59;"	d	file:
fsm	fsm.h	/^typedef struct fsm {$/;"	s
fsm	fsm.h	/^} fsm;$/;"	t
fsm_callbacks	fsm.h	/^typedef struct fsm_callbacks {$/;"	s
fsm_callbacks	fsm.h	/^} fsm_callbacks;$/;"	t
fsm_close	fsm.c	/^fsm_close(f, reason)$/;"	f
fsm_init	fsm.c	/^fsm_init(f)$/;"	f
fsm_input	fsm.c	/^fsm_input(f, inpacket, l)$/;"	f
fsm_lowerdown	fsm.c	/^fsm_lowerdown(f)$/;"	f
fsm_lowerup	fsm.c	/^fsm_lowerup(f)$/;"	f
fsm_open	fsm.c	/^fsm_open(f)$/;"	f
fsm_protreject	fsm.c	/^fsm_protreject(f)$/;"	f
fsm_rcoderej	fsm.c	/^fsm_rcoderej(f, inp, len)$/;"	f	file:
fsm_rconfack	fsm.c	/^fsm_rconfack(f, id, inp, len)$/;"	f	file:
fsm_rconfnakrej	fsm.c	/^fsm_rconfnakrej(f, code, id, inp, len)$/;"	f	file:
fsm_rconfreq	fsm.c	/^fsm_rconfreq(f, id, inp, len)$/;"	f	file:
fsm_rtermack	fsm.c	/^fsm_rtermack(f)$/;"	f	file:
fsm_rtermreq	fsm.c	/^fsm_rtermreq(f, id, p, len)$/;"	f	file:
fsm_sconfreq	fsm.c	/^fsm_sconfreq(f, retransmit)$/;"	f	file:
fsm_sdata	fsm.c	/^fsm_sdata(f, code, id, data, datalen)$/;"	f
fsm_timeout	fsm.c	/^fsm_timeout(arg)$/;"	f	file:
full_hash	tdb.c	/^	unsigned full_hash; \/* the full 32 bit hash of the key *\/$/;"	m	struct:list_struct	file:
func	pppd.h	/^    notify_func	    func;$/;"	m	struct:notifier
g	md4.c	75;"	d	file:
general_options	options.c	/^option_t general_options[] = {$/;"	v
get_default_epdisc	multilink.c	/^get_default_epdisc(ep)$/;"	f	file:
get_ether_addr	sys-linux.c	/^static int get_ether_addr (u_int32_t ipaddr,$/;"	f	file:
get_ether_addr	sys-solaris.c	/^get_ether_addr(ipaddr, hwaddr)$/;"	f	file:
get_ether_addr	sys-sunos4.c	/^get_ether_addr(ipaddr, hwaddr)$/;"	f	file:
get_first_ethernet	sys-linux.c	/^get_first_ethernet()$/;"	f
get_first_ethernet	sys-solaris.c	/^get_first_ethernet()$/;"	f
get_flags	sys-linux.c	/^static int get_flags (int fd)$/;"	f	file:
get_host_seed	sys-linux.c	/^get_host_seed()$/;"	f
get_host_seed	sys-solaris.c	/^get_host_seed()$/;"	f
get_host_seed	sys-sunos4.c	/^get_host_seed()$/;"	f
get_hw_addr	sys-solaris.c	/^get_hw_addr(name, ina, hwaddr)$/;"	f	file:
get_hw_addr_dlpi	sys-solaris.c	/^get_hw_addr_dlpi(name, hwaddr)$/;"	f	file:
get_idle_time	sys-linux.c	/^get_idle_time(u, ip)$/;"	f
get_idle_time	sys-solaris.c	/^get_idle_time(u, ip)$/;"	f
get_idle_time	sys-sunos4.c	/^get_idle_time(u, ip)$/;"	f
get_if_hwaddr	sys-linux.c	/^get_if_hwaddr(u_char *addr, char *name)$/;"	f
get_if_hwaddr	sys-solaris.c	/^get_if_hwaddr(u_char *addr, char *if_name)$/;"	f
get_input	main.c	/^get_input()$/;"	f	file:
get_input	main.old.c	/^get_input()$/;"	f	file:
get_ip6nh	ipv6cp.c	1487;"	d	file:
get_iphl	ipcp.c	2025;"	d	file:
get_ipoff	ipcp.c	2026;"	d	file:
get_ipproto	ipcp.c	2027;"	d	file:
get_loop_output	sys-linux.c	/^get_loop_output(void)$/;"	f
get_loop_output	sys-solaris.c	/^get_loop_output()$/;"	f
get_loop_output	sys-sunos4.c	/^get_loop_output()$/;"	f
get_pap_passwd	auth.c	/^get_pap_passwd(passwd)$/;"	f	file:
get_ppp_stats	sys-linux.c	/^get_ppp_stats(u, stats)$/;"	f
get_ppp_stats	sys-solaris.c	/^get_ppp_stats(u, stats)$/;"	f
get_ppp_stats	sys-sunos4.c	/^get_ppp_stats(u, stats)$/;"	f
get_pty	sys-linux.c	/^get_pty(master_fdp, slave_fdp, slave_name, uid)$/;"	f
get_pty	sys-solaris.c	/^get_pty(master_fdp, slave_fdp, slave_name, uid)$/;"	f
get_pty	sys-sunos4.c	/^get_pty(master_fdp, slave_fdp, slave_name, uid)$/;"	f
get_secret	auth.c	/^get_secret(unit, client, server, secret, secret_len, am_server)$/;"	f
get_tcpflags	ipcp.c	2029;"	d	file:
get_tcpflags	ipv6cp.c	1489;"	d	file:
get_tcpoff	ipcp.c	2028;"	d	file:
get_tcpoff	ipv6cp.c	1488;"	d	file:
getword	options.c	/^getword(f, word, newlinep, filename)$/;"	f
gg	md4.c	79;"	d	file:
go	ipxcp.c	52;"	d	file:
got_sigchld	main.c	/^static int got_sigchld;		\/* set if we have received a SIGCHLD *\/$/;"	v	file:
got_sigchld	main.old.c	/^static int got_sigchld;		\/* set if we have received a SIGCHLD *\/$/;"	v	file:
got_sighup	main.c	/^int got_sighup;$/;"	v
got_sighup	main.old.c	/^int got_sighup;$/;"	v
got_sigterm	main.c	/^int got_sigterm;$/;"	v
got_sigterm	main.old.c	/^int got_sigterm;$/;"	v
got_sigusr2	main.c	/^int got_sigusr2;$/;"	v
got_sigusr2	main.old.c	/^int got_sigusr2;$/;"	v
groups	main.c	/^GIDSET_TYPE groups[NGROUPS_MAX];\/* groups the user is in *\/$/;"	v
groups	main.old.c	/^GIDSET_TYPE groups[NGROUPS_MAX];\/* groups the user is in *\/$/;"	v
gs1	md4.c	60;"	d	file:
gs2	md4.c	61;"	d	file:
gs3	md4.c	62;"	d	file:
gs4	md4.c	63;"	d	file:
h	md4.c	76;"	d	file:
handle_events	main.c	/^handle_events()$/;"	f	file:
handle_events	main.old.c	/^handle_events()$/;"	f	file:
has_proxy_arp	sys-linux.c	/^static int has_proxy_arp       = 0;$/;"	v	file:
hash_size	tdb.h	/^	unsigned hash_size; \/* number of hash entries *\/$/;"	m	struct:tdb_header
have_chap_secret	auth.c	/^have_chap_secret(client, server, need_ip, lacks_ipp)$/;"	f	file:
have_pap_secret	auth.c	/^have_pap_secret(lacks_ipp)$/;"	f	file:
have_route_to	sys-linux.c	/^int have_route_to(u_int32_t addr)$/;"	f
have_route_to	sys-solaris.c	/^have_route_to(addr)$/;"	f
have_route_to	sys-sunos4.c	/^int have_route_to(addr)$/;"	f
header	tdb.h	/^	struct tdb_header header; \/* a cached copy of the header *\/$/;"	m	struct:
hexc_val	multilink.c	/^static int hexc_val(int c)$/;"	f	file:
hh	md4.c	80;"	d	file:
hide_password	upap.c	/^static bool hide_password = 1;$/;"	v	file:
his_network	ipxcp.h	/^    u_int32_t his_network;	\/* base network number *\/$/;"	m	struct:ipxcp_options
his_node	ipxcp.h	/^    u_char his_node[6];		\/* peer's node number *\/$/;"	m	struct:ipxcp_options
hisaddr	ipcp.h	/^    u_int32_t ouraddr, hisaddr;	\/* Addresses in NETWORK BYTE ORDER *\/$/;"	m	struct:ipcp_options
hisid	ipv6cp.h	/^    eui64_t ourid, hisid;	\/* Interface identifiers *\/$/;"	m	struct:ipv6cp_options
ho	ipxcp.c	53;"	d	file:
holdoff	options.c	/^int	holdoff = 30;		\/* # seconds to pause before reconnecting *\/$/;"	v
holdoff_end	main.c	/^holdoff_end(arg)$/;"	f	file:
holdoff_end	main.old.c	/^holdoff_end(arg)$/;"	f	file:
holdoff_hook	main.c	/^int (*holdoff_hook) __P((void)) = NULL;$/;"	v
holdoff_hook	main.old.c	/^int (*holdoff_hook) __P((void)) = NULL;$/;"	v
holdoff_specified	options.c	/^bool	holdoff_specified;	\/* true if a holdoff value has been given *\/$/;"	v
hostname	main.c	/^char hostname[MAXNAMELEN];	\/* Our hostname *\/$/;"	v
hostname	main.old.c	/^char hostname[MAXNAMELEN];	\/* Our hostname *\/$/;"	v
hs1	md4.c	64;"	d	file:
hs2	md4.c	65;"	d	file:
hs3	md4.c	66;"	d	file:
hs4	md4.c	67;"	d	file:
hungup	main.c	/^int hungup;			\/* terminal has been hung up *\/$/;"	v
hungup	main.old.c	/^int hungup;			\/* terminal has been hung up *\/$/;"	v
hup	main.c	/^hup(sig)$/;"	f	file:
hup	main.old.c	/^hup(sig)$/;"	f	file:
i	md5.h	/^  UINT4 i[2];                   \/* number of _bits_ handled mod 2^64 *\/$/;"	m	struct:
id	chap.h	/^    u_char id;			\/* Current id *\/$/;"	m	struct:chap_state
id	fsm.h	/^    u_char id;			\/* Current id *\/$/;"	m	struct:fsm
idle_time_hook	auth.c	/^int (*idle_time_hook) __P((struct ppp_idle *)) = NULL;$/;"	v
idle_time_limit	options.c	/^int	idle_time_limit = 0;	\/* Disconnect if idle for this many seconds *\/$/;"	v
if6_is_up	sys-solaris.c	/^static int	if6_is_up = 0;	\/* IPv6 interface has been marked up *\/$/;"	v	file:
if_is_up	sys-linux.c	/^static int	if_is_up;	\/* Interface has been marked up *\/$/;"	v	file:
if_is_up	sys-solaris.c	/^static int	if_is_up;	\/* Interface has been marked up *\/$/;"	v	file:
if_is_up	sys-sunos4.c	/^static int	if_is_up;	\/* Interface has been marked up *\/$/;"	v	file:
ifaddrs	sys-sunos4.c	/^static u_int32_t ifaddrs[2];	\/* local and remote addresses *\/$/;"	v	file:
iffd	sys-sunos4.c	/^static int	iffd;$/;"	v	file:
ifname	main.c	/^char ifname[32];		\/* Interface name *\/$/;"	v
ifname	main.old.c	/^char ifname[32];		\/* Interface name *\/$/;"	v
ifr6_addr	sys-linux.c	/^    struct in6_addr ifr6_addr;$/;"	m	struct:in6_ifreq	file:
ifr6_ifindex	sys-linux.c	/^    unsigned int ifr6_ifindex;$/;"	m	struct:in6_ifreq	file:
ifr6_prefixlen	sys-linux.c	/^    __u32 ifr6_prefixlen;$/;"	m	struct:in6_ifreq	file:
ifunit	main.c	/^int ifunit;			\/* Interface unit number *\/$/;"	v
ifunit	main.old.c	/^int ifunit;			\/* Interface unit number *\/$/;"	v
in	md5.h	/^  unsigned char in[64];                              \/* input buffer *\/$/;"	m	struct:
in6_ifreq	sys-linux.c	/^struct in6_ifreq {$/;"	s	file:
in_fds	sys-linux.c	/^static fd_set in_fds;		\/* set of fds that wait_input waits for *\/$/;"	v	file:
inbuf	sys-linux.c	/^static unsigned char inbuf[512]; \/* buffer for chars read from loopback *\/$/;"	v	file:
inc_node	ipxcp.c	/^inc_node (node)$/;"	f	file:
info	utils.c	/^info __V((char *fmt, ...))$/;"	f
init	pppd.h	/^    void (*init) __P((int unit));$/;"	m	struct:protent
init_pr_log	utils.c	/^init_pr_log(prefix, level)$/;"	f
initfdflags	sys-linux.c	/^static int initfdflags = -1;	\/* Initial file descriptor flags for fd *\/$/;"	v	file:
initializer	tty.c	/^char	*initializer = NULL;	\/* Script to initialize physical link *\/$/;"	v
inittermios	sys-linux.c	/^static struct termios inittermios;	\/* Initial TTY termios *\/$/;"	v	file:
inittermios	sys-solaris.c	/^static struct termios inittermios;$/;"	v	file:
inittermios	sys-sunos4.c	/^static struct termios inittermios;$/;"	v	file:
inittermiox	sys-solaris.c	/^static struct termiox inittermiox;$/;"	v	file:
inpacket_buf	main.c	/^u_char inpacket_buf[PPP_MRU+PPP_HDRLEN]; \/* buffer for incoming packet *\/$/;"	v
inpacket_buf	main.old.c	/^u_char inpacket_buf[PPP_MRU+PPP_HDRLEN]; \/* buffer for incoming packet *\/$/;"	v
input	pppd.h	/^    void (*input) __P((int unit, u_char *pkt, int len));$/;"	m	struct:protent
inspeed	tty.c	/^int	inspeed = 0;		\/* Input\/Output speed requested *\/$/;"	v
int_option	options.c	/^int_option(str, valp)$/;"	f
ip6fd	sys-solaris.c	/^static int	ip6fd;		\/* IP file descriptor *\/$/;"	v	file:
ip6muxid	sys-solaris.c	/^static int	ip6muxid = -1;	\/* Multiplexer file descriptor *\/$/;"	v	file:
ip_active_pkt	ipcp.c	/^ip_active_pkt(pkt, len)$/;"	f	file:
ip_addr_check	auth.c	/^ip_addr_check(addr, addrs)$/;"	f	file:
ip_check_options	ipcp.c	/^ip_check_options()$/;"	f	file:
ip_choose_hook	ipcp.c	/^void (*ip_choose_hook) __P((u_int32_t *)) = NULL;$/;"	v
ip_demand_conf	ipcp.c	/^ip_demand_conf(u)$/;"	f	file:
ip_down_hook	ipcp.c	/^void (*ip_down_hook) __P((void)) = NULL;$/;"	v
ip_ntoa	ipcp.c	/^ip_ntoa(ipaddr)$/;"	f
ip_up_hook	ipcp.c	/^void (*ip_up_hook) __P((void)) = NULL;$/;"	v
ipcp_ackci	ipcp.c	/^ipcp_ackci(f, p, len)$/;"	f	file:
ipcp_addci	ipcp.c	/^ipcp_addci(f, ucp, lenp)$/;"	f	file:
ipcp_allowoptions	ipcp.c	/^ipcp_options ipcp_allowoptions[NUM_PPP]; \/* Options we allow peer to request *\/$/;"	v
ipcp_callbacks	ipcp.c	/^static fsm_callbacks ipcp_callbacks = { \/* IPCP callback routines *\/$/;"	v	file:
ipcp_cilen	ipcp.c	/^ipcp_cilen(f)$/;"	f	file:
ipcp_clear_addrs	ipcp.c	/^ipcp_clear_addrs(unit, ouraddr, hisaddr)$/;"	f	file:
ipcp_close	ipcp.c	/^ipcp_close(unit, reason)$/;"	f	file:
ipcp_codenames	ipcp.c	/^static char *ipcp_codenames[] = {$/;"	v	file:
ipcp_down	ipcp.c	/^ipcp_down(f)$/;"	f	file:
ipcp_finished	ipcp.c	/^ipcp_finished(f)$/;"	f	file:
ipcp_fsm	ipcp.c	/^fsm ipcp_fsm[NUM_PPP];		\/* IPCP fsm structure *\/$/;"	v
ipcp_gotoptions	ipcp.c	/^ipcp_options ipcp_gotoptions[NUM_PPP];	\/* Options that peer ack'd *\/$/;"	v
ipcp_hisoptions	ipcp.c	/^ipcp_options ipcp_hisoptions[NUM_PPP];	\/* Options that we ack'd *\/$/;"	v
ipcp_init	ipcp.c	/^ipcp_init(unit)$/;"	f	file:
ipcp_input	ipcp.c	/^ipcp_input(unit, p, len)$/;"	f	file:
ipcp_is_up	ipcp.c	/^static int ipcp_is_up;			\/* have called np_up() *\/$/;"	v	file:
ipcp_lowerdown	ipcp.c	/^ipcp_lowerdown(unit)$/;"	f	file:
ipcp_lowerup	ipcp.c	/^ipcp_lowerup(unit)$/;"	f	file:
ipcp_nakci	ipcp.c	/^ipcp_nakci(f, p, len)$/;"	f	file:
ipcp_open	ipcp.c	/^ipcp_open(unit)$/;"	f	file:
ipcp_option_list	ipcp.c	/^static option_t ipcp_option_list[] = {$/;"	v	file:
ipcp_options	ipcp.h	/^typedef struct ipcp_options {$/;"	s
ipcp_options	ipcp.h	/^} ipcp_options;$/;"	t
ipcp_printpkt	ipcp.c	/^ipcp_printpkt(p, plen, printer, arg)$/;"	f	file:
ipcp_protent	ipcp.c	/^struct protent ipcp_protent = {$/;"	v
ipcp_protrej	ipcp.c	/^ipcp_protrej(unit)$/;"	f	file:
ipcp_rejci	ipcp.c	/^ipcp_rejci(f, p, len)$/;"	f	file:
ipcp_reqci	ipcp.c	/^ipcp_reqci(f, inp, len, reject_if_disagree)$/;"	f	file:
ipcp_resetci	ipcp.c	/^ipcp_resetci(f)$/;"	f	file:
ipcp_script	ipcp.c	/^ipcp_script(script)$/;"	f	file:
ipcp_script_done	ipcp.c	/^ipcp_script_done(arg)$/;"	f	file:
ipcp_script_pid	ipcp.c	/^static pid_t ipcp_script_pid;$/;"	v	file:
ipcp_script_state	ipcp.c	/^} ipcp_script_state;$/;"	v	file:
ipcp_up	ipcp.c	/^ipcp_up(f)$/;"	f	file:
ipcp_wantoptions	ipcp.c	/^ipcp_options ipcp_wantoptions[NUM_PPP];	\/* Options that we want to request *\/$/;"	v
ipfd	sys-solaris.c	/^static int	ipfd;$/;"	v	file:
ipmuxid	sys-solaris.c	/^static int	ipmuxid = -1;$/;"	v	file:
ipparam	options.c	/^char	*ipparam = NULL;	\/* Extra parameter for ip up\/down scripts *\/$/;"	v
ipv6_active_pkt	ipv6cp.c	/^ipv6_active_pkt(pkt, len)$/;"	f	file:
ipv6_check_options	ipv6cp.c	/^ipv6_check_options()$/;"	f	file:
ipv6_demand_conf	ipv6cp.c	/^ipv6_demand_conf(u)$/;"	f	file:
ipv6cp_ackci	ipv6cp.c	/^ipv6cp_ackci(f, p, len)$/;"	f	file:
ipv6cp_addci	ipv6cp.c	/^ipv6cp_addci(f, ucp, lenp)$/;"	f	file:
ipv6cp_allowoptions	ipv6cp.c	/^ipv6cp_options ipv6cp_allowoptions[NUM_PPP];	\/* Options we allow peer to request *\/$/;"	v
ipv6cp_callbacks	ipv6cp.c	/^static fsm_callbacks ipv6cp_callbacks = { \/* IPV6CP callback routines *\/$/;"	v	file:
ipv6cp_cilen	ipv6cp.c	/^ipv6cp_cilen(f)$/;"	f	file:
ipv6cp_clear_addrs	ipv6cp.c	/^ipv6cp_clear_addrs(unit, ourid, hisid)$/;"	f	file:
ipv6cp_close	ipv6cp.c	/^ipv6cp_close(unit, reason)$/;"	f	file:
ipv6cp_codenames	ipv6cp.c	/^static char *ipv6cp_codenames[] = {$/;"	v	file:
ipv6cp_down	ipv6cp.c	/^ipv6cp_down(f)$/;"	f	file:
ipv6cp_finished	ipv6cp.c	/^ipv6cp_finished(f)$/;"	f	file:
ipv6cp_fsm	ipv6cp.c	/^fsm ipv6cp_fsm[NUM_PPP];		\/* IPV6CP fsm structure *\/$/;"	v
ipv6cp_gotoptions	ipv6cp.c	/^ipv6cp_options ipv6cp_gotoptions[NUM_PPP];	\/* Options that peer ack'd *\/$/;"	v
ipv6cp_hisoptions	ipv6cp.c	/^ipv6cp_options ipv6cp_hisoptions[NUM_PPP];	\/* Options that we ack'd *\/$/;"	v
ipv6cp_init	ipv6cp.c	/^ipv6cp_init(unit)$/;"	f	file:
ipv6cp_input	ipv6cp.c	/^ipv6cp_input(unit, p, len)$/;"	f	file:
ipv6cp_is_up	ipv6cp.c	/^static int ipv6cp_is_up;$/;"	v	file:
ipv6cp_lowerdown	ipv6cp.c	/^ipv6cp_lowerdown(unit)$/;"	f	file:
ipv6cp_lowerup	ipv6cp.c	/^ipv6cp_lowerup(unit)$/;"	f	file:
ipv6cp_nakci	ipv6cp.c	/^ipv6cp_nakci(f, p, len)$/;"	f	file:
ipv6cp_open	ipv6cp.c	/^ipv6cp_open(unit)$/;"	f	file:
ipv6cp_option_list	ipv6cp.c	/^static option_t ipv6cp_option_list[] = {$/;"	v	file:
ipv6cp_options	ipv6cp.h	/^typedef struct ipv6cp_options {$/;"	s
ipv6cp_options	ipv6cp.h	/^} ipv6cp_options;$/;"	t
ipv6cp_printpkt	ipv6cp.c	/^ipv6cp_printpkt(p, plen, printer, arg)$/;"	f	file:
ipv6cp_protent	ipv6cp.c	/^struct protent ipv6cp_protent = {$/;"	v
ipv6cp_protrej	ipv6cp.c	/^ipv6cp_protrej(unit)$/;"	f	file:
ipv6cp_rejci	ipv6cp.c	/^ipv6cp_rejci(f, p, len)$/;"	f	file:
ipv6cp_reqci	ipv6cp.c	/^ipv6cp_reqci(f, inp, len, reject_if_disagree)$/;"	f	file:
ipv6cp_resetci	ipv6cp.c	/^ipv6cp_resetci(f)$/;"	f	file:
ipv6cp_script	ipv6cp.c	/^ipv6cp_script(script)$/;"	f	file:
ipv6cp_script_done	ipv6cp.c	/^ipv6cp_script_done(arg)$/;"	f	file:
ipv6cp_script_pid	ipv6cp.c	/^static pid_t ipv6cp_script_pid;$/;"	v	file:
ipv6cp_script_state	ipv6cp.c	/^} ipv6cp_script_state;$/;"	v	file:
ipv6cp_up	ipv6cp.c	/^ipv6cp_up(f)$/;"	f	file:
ipv6cp_wantoptions	ipv6cp.c	/^ipv6cp_options ipv6cp_wantoptions[NUM_PPP];     \/* Options that we want to request *\/$/;"	v
ipx_ntoa	ipxcp.c	/^ipx_ntoa(ipxaddr)$/;"	f	file:
ipx_prio_his	ipxcp.c	/^static int ipx_prio_our, ipx_prio_his;$/;"	v	file:
ipx_prio_our	ipxcp.c	/^static int ipx_prio_our, ipx_prio_his;$/;"	v	file:
ipxcp_ackci	ipxcp.c	/^ipxcp_ackci(f, p, len)$/;"	f	file:
ipxcp_addci	ipxcp.c	/^ipxcp_addci(f, ucp, lenp)$/;"	f	file:
ipxcp_allowoptions	ipxcp.c	/^ipxcp_options ipxcp_allowoptions[NUM_PPP];	\/* Options we allow peer to request *\/$/;"	v
ipxcp_callbacks	ipxcp.c	/^static fsm_callbacks ipxcp_callbacks = { \/* IPXCP callback routines *\/$/;"	v	file:
ipxcp_cilen	ipxcp.c	/^ipxcp_cilen(f)$/;"	f	file:
ipxcp_close	ipxcp.c	/^ipxcp_close(unit, reason)$/;"	f	file:
ipxcp_codenames	ipxcp.c	/^static char *ipxcp_codenames[] = {$/;"	v	file:
ipxcp_down	ipxcp.c	/^ipxcp_down(f)$/;"	f	file:
ipxcp_finished	ipxcp.c	/^ipxcp_finished(f)$/;"	f	file:
ipxcp_fsm	ipxcp.c	/^fsm ipxcp_fsm[NUM_PPP];		\/* IPXCP fsm structure *\/$/;"	v
ipxcp_gotoptions	ipxcp.c	/^ipxcp_options ipxcp_gotoptions[NUM_PPP];	\/* Options that peer ack'd *\/$/;"	v
ipxcp_hisoptions	ipxcp.c	/^ipxcp_options ipxcp_hisoptions[NUM_PPP];	\/* Options that we ack'd *\/$/;"	v
ipxcp_init	ipxcp.c	/^ipxcp_init(unit)$/;"	f	file:
ipxcp_input	ipxcp.c	/^ipxcp_input(unit, p, len)$/;"	f	file:
ipxcp_is_up	ipxcp.c	/^static int ipxcp_is_up;$/;"	v	file:
ipxcp_lowerdown	ipxcp.c	/^ipxcp_lowerdown(unit)$/;"	f	file:
ipxcp_lowerup	ipxcp.c	/^ipxcp_lowerup(unit)$/;"	f	file:
ipxcp_nakci	ipxcp.c	/^ipxcp_nakci(f, p, len)$/;"	f	file:
ipxcp_open	ipxcp.c	/^ipxcp_open(unit)$/;"	f	file:
ipxcp_option_list	ipxcp.c	/^static option_t ipxcp_option_list[] = {$/;"	v	file:
ipxcp_options	ipxcp.h	/^typedef struct ipxcp_options {$/;"	s
ipxcp_options	ipxcp.h	/^} ipxcp_options;$/;"	t
ipxcp_printpkt	ipxcp.c	/^ipxcp_printpkt(p, plen, printer, arg)$/;"	f	file:
ipxcp_protent	ipxcp.c	/^struct protent ipxcp_protent = {$/;"	v
ipxcp_protrej	ipxcp.c	/^ipxcp_protrej(unit)$/;"	f	file:
ipxcp_rejci	ipxcp.c	/^ipxcp_rejci(f, p, len)$/;"	f	file:
ipxcp_reqci	ipxcp.c	/^ipxcp_reqci(f, inp, len, reject_if_disagree)$/;"	f	file:
ipxcp_resetci	ipxcp.c	/^ipxcp_resetci(f)$/;"	f	file:
ipxcp_script	ipxcp.c	/^ipxcp_script(f, script)$/;"	f	file:
ipxcp_up	ipxcp.c	/^ipxcp_up(f)$/;"	f	file:
ipxcp_wantoptions	ipxcp.c	/^ipxcp_options ipxcp_wantoptions[NUM_PPP];	\/* Options that we want to request *\/$/;"	v
isoctal	options.c	1052;"	d	file:
isoctal	options.c	1277;"	d	file:
kdebugflag	options.c	/^int	kdebugflag = 0;		\/* Tell kernel to print debug messages *\/$/;"	v
kernel_version	sys-linux.c	/^static int kernel_version;$/;"	v	file:
key_len	tdb.c	/^	tdb_len key_len; \/* byte length of key *\/$/;"	m	struct:list_struct	file:
kill_link	main.c	/^int kill_link;$/;"	v
kill_link	main.old.c	/^int kill_link;$/;"	v
kill_my_pg	main.c	/^kill_my_pg(sig)$/;"	f	file:
kill_my_pg	main.old.c	/^kill_my_pg(sig)$/;"	f	file:
lax_recv	lcp.c	/^bool	lax_recv = 0;		\/* accept control chars in asyncmap *\/$/;"	v
lcp_ackci	lcp.c	/^lcp_ackci(f, p, len)$/;"	f	file:
lcp_addci	lcp.c	/^lcp_addci(f, ucp, lenp)$/;"	f	file:
lcp_allowoptions	lcp.c	/^lcp_options lcp_allowoptions[NUM_PPP];	\/* Options we allow peer to request *\/$/;"	v
lcp_callbacks	lcp.c	/^static fsm_callbacks lcp_callbacks = {	\/* LCP callback routines *\/$/;"	v	file:
lcp_cilen	lcp.c	/^lcp_cilen(f)$/;"	f	file:
lcp_close	lcp.c	/^lcp_close(unit, reason)$/;"	f
lcp_codenames	lcp.c	/^static char *lcp_codenames[] = {$/;"	v	file:
lcp_delayed_up	lcp.c	/^lcp_delayed_up(arg)$/;"	f	file:
lcp_down	lcp.c	/^lcp_down(f)$/;"	f	file:
lcp_echo_fails	lcp.c	/^int	lcp_echo_fails = 0;	\/* Tolerance to unanswered echo-requests *\/$/;"	v
lcp_echo_interval	lcp.c	/^int	lcp_echo_interval = 0; 	\/* Interval between LCP echo-requests *\/$/;"	v
lcp_echo_lowerdown	lcp.c	/^lcp_echo_lowerdown (unit)$/;"	f	file:
lcp_echo_lowerup	lcp.c	/^lcp_echo_lowerup (unit)$/;"	f	file:
lcp_echo_number	lcp.c	/^static int lcp_echo_number   = 0;	\/* ID number of next echo frame *\/$/;"	v	file:
lcp_echo_timer_running	lcp.c	/^static int lcp_echo_timer_running = 0;  \/* set if a timer is running *\/$/;"	v	file:
lcp_echos_pending	lcp.c	/^static int lcp_echos_pending = 0;	\/* Number of outstanding echo msgs *\/$/;"	v	file:
lcp_extcode	lcp.c	/^lcp_extcode(f, code, id, inp, len)$/;"	f	file:
lcp_finished	lcp.c	/^lcp_finished(f)$/;"	f	file:
lcp_fsm	lcp.c	/^fsm lcp_fsm[NUM_PPP];			\/* LCP fsm structure (global)*\/$/;"	v
lcp_gotoptions	lcp.c	/^lcp_options lcp_gotoptions[NUM_PPP];	\/* Options that peer ack'd *\/$/;"	v
lcp_hisoptions	lcp.c	/^lcp_options lcp_hisoptions[NUM_PPP];	\/* Options that we ack'd *\/$/;"	v
lcp_init	lcp.c	/^lcp_init(unit)$/;"	f	file:
lcp_input	lcp.c	/^lcp_input(unit, p, len)$/;"	f	file:
lcp_loopbackfail	lcp.c	/^int lcp_loopbackfail = DEFLOOPBACKFAIL;$/;"	v
lcp_lowerdown	lcp.c	/^lcp_lowerdown(unit)$/;"	f
lcp_lowerup	lcp.c	/^lcp_lowerup(unit)$/;"	f
lcp_nakci	lcp.c	/^lcp_nakci(f, p, len)$/;"	f	file:
lcp_open	lcp.c	/^lcp_open(unit)$/;"	f
lcp_option_list	lcp.c	/^static option_t lcp_option_list[] = {$/;"	v	file:
lcp_options	lcp.h	/^typedef struct lcp_options {$/;"	s
lcp_options	lcp.h	/^} lcp_options;$/;"	t
lcp_printpkt	lcp.c	/^lcp_printpkt(p, plen, printer, arg)$/;"	f	file:
lcp_protent	lcp.c	/^struct protent lcp_protent = {$/;"	v
lcp_protrej	lcp.c	/^lcp_protrej(unit)$/;"	f	file:
lcp_received_echo_reply	lcp.c	/^lcp_received_echo_reply (f, id, inp, len)$/;"	f	file:
lcp_rejci	lcp.c	/^lcp_rejci(f, p, len)$/;"	f	file:
lcp_reqci	lcp.c	/^lcp_reqci(f, inp, lenp, reject_if_disagree)$/;"	f	file:
lcp_resetci	lcp.c	/^lcp_resetci(f)$/;"	f	file:
lcp_rprotrej	lcp.c	/^lcp_rprotrej(f, inp, len)$/;"	f	file:
lcp_sprotrej	lcp.c	/^lcp_sprotrej(unit, p, len)$/;"	f
lcp_starting	lcp.c	/^lcp_starting(f)$/;"	f	file:
lcp_up	lcp.c	/^lcp_up(f)$/;"	f	file:
lcp_wantoptions	lcp.c	/^lcp_options lcp_wantoptions[NUM_PPP];	\/* Options that we want to request *\/$/;"	v
len	utils.c	/^    int len;$/;"	m	struct:buffer_info	file:
length	demand.c	/^    int length;$/;"	m	struct:packet	file:
length	pppd.h	/^    unsigned char	length;$/;"	m	struct:epdisc
line	utils.c	/^static char line[256];		\/* line to be logged accumulated here *\/$/;"	v	file:
linep	utils.c	/^static char *linep;		\/* current pointer within line *\/$/;"	v	file:
link_connect_time	main.c	/^int link_connect_time;$/;"	v
link_connect_time	main.old.c	/^int link_connect_time;$/;"	v
link_down	auth.c	/^link_down(unit)$/;"	f
link_established	auth.c	/^link_established(unit)$/;"	f
link_mru	sys-solaris.c	/^static int	link_mtu, link_mru;$/;"	v	file:
link_mru	sys-sunos4.c	/^static int	link_mtu, link_mru;$/;"	v	file:
link_mtu	sys-linux.c	/^static int	link_mtu;		\/* mtu for the link (not bundle) *\/$/;"	v	file:
link_mtu	sys-solaris.c	/^static int	link_mtu, link_mru;$/;"	v	file:
link_mtu	sys-sunos4.c	/^static int	link_mtu, link_mru;$/;"	v	file:
link_required	auth.c	/^link_required(unit)$/;"	f
link_stats	main.c	/^struct pppd_stats link_stats;$/;"	v
link_stats	main.old.c	/^struct pppd_stats link_stats;$/;"	v
link_stats_valid	main.c	/^int link_stats_valid;$/;"	v
link_stats_valid	main.old.c	/^int link_stats_valid;$/;"	v
link_terminated	auth.c	/^link_terminated(unit)$/;"	f
linkname	options.c	/^char	linkname[MAXPATHLEN];	\/* logical name for link *\/$/;"	v
linkpidfile	main.c	/^static char linkpidfile[MAXPATHLEN];	\/* name of linkname pid file *\/$/;"	v	file:
linkpidfile	main.old.c	/^static char linkpidfile[MAXPATHLEN];	\/* name of linkname pid file *\/$/;"	v	file:
list_struct	tdb.c	/^struct list_struct {$/;"	s	file:
listen_time	main.c	/^int listen_time;$/;"	v
listen_time	main.old.c	/^int listen_time;$/;"	v
llevel	utils.c	/^static int llevel;		\/* level for logging *\/$/;"	v	file:
llv6_ntoa	ipv6cp.c	/^llv6_ntoa(ifaceid)$/;"	f
loadplugin	options.c	/^loadplugin(argv)$/;"	f	file:
lock	sys-solaris.c	/^lock(dev)$/;"	f
lock	utils.c	/^lock(dev)$/;"	f
lock_file	sys-solaris.c	/^static char lock_file[40];	\/* name of lock file created *\/$/;"	v	file:
lock_file	utils.c	/^static char lock_file[MAXPATHLEN];$/;"	v	file:
locked	tdb.h	/^	int *locked; \/* set if we have a chain locked *\/$/;"	m	struct:
locked	tty.c	/^int locked;			\/* lock() has succeeded *\/$/;"	v
lockflag	tty.c	/^bool	lockflag = 0;		\/* Create lock file to lock the serial dev *\/$/;"	v
log_default	options.c	/^bool	log_default = 1;	\/* log_to_fd is default (stdout) *\/$/;"	v
log_packet	utils.c	/^log_packet(p, len, prefix, level)$/;"	f
log_to_fd	options.c	/^int	log_to_fd = 1;		\/* send log messages to this fd too *\/$/;"	v
log_write	utils.c	/^log_write(level, buf)$/;"	f	file:
logfile_fd	options.c	/^static int logfile_fd = -1;	\/* fd opened for log file *\/$/;"	v	file:
logfile_name	options.c	/^static char logfile_name[MAXPATHLEN];	\/* name of log file *\/$/;"	v	file:
logged_in	auth.c	/^static int logged_in;$/;"	v	file:
logit	utils.c	/^logit(level, fmt, args)$/;"	f	file:
logwtmp	sys-linux.c	/^void logwtmp (const char *line, const char *name, const char *host)$/;"	f
logwtmp	sys-solaris.c	/^logwtmp(line, name, host)$/;"	f
logwtmp	sys-sunos4.c	/^logwtmp(line, name, host)$/;"	f
loop_chars	demand.c	/^loop_chars(p, n)$/;"	f
loop_frame	demand.c	/^loop_frame(frame, len)$/;"	f
loop_name	sys-linux.c	/^static char loop_name[20];$/;"	v	file:
looped	sys-linux.c	/^static int	looped;			\/* 1 if using loop *\/$/;"	v	file:
lower_limit	pppd.h	/^	int	lower_limit;$/;"	m	struct:
lowerdown	pppd.h	/^    void (*lowerdown) __P((int unit));$/;"	m	struct:protent
lowerup	pppd.h	/^    void (*lowerup) __P((int unit));$/;"	m	struct:protent
lqr_period	lcp.h	/^    u_int32_t lqr_period;	\/* Reporting period for LQR 1\/100ths second *\/$/;"	m	struct:lcp_options
magic	magic.c	/^magic()$/;"	f
magic	tdb.c	/^	unsigned magic;   \/* try to catch errors *\/$/;"	m	struct:list_struct	file:
magic_food	tdb.h	/^	char magic_food[32]; \/* for \/etc\/magic *\/$/;"	m	struct:tdb_header
magic_init	magic.c	/^magic_init()$/;"	f
magicnumber	lcp.h	/^    u_int32_t magicnumber;$/;"	m	struct:lcp_options
main	main.c	/^main(argc, argv)$/;"	f
main	main.old.c	/^main(argc, argv)$/;"	f
make_new_bundle	sys-linux.c	/^void make_new_bundle(int mrru, int mtru, int rssn, int tssn)$/;"	f
make_ppp_unit	sys-linux.c	/^static int make_ppp_unit()$/;"	f	file:
map_ptr	tdb.h	/^	void *map_ptr; \/* where it is currently mapped *\/$/;"	m	struct:
map_size	tdb.h	/^	tdb_len map_size; \/* how much space has been mapped *\/$/;"	m	struct:
mask	pppd.h	/^    u_int32_t	mask;		\/* base and mask are in network byte order *\/$/;"	m	struct:permitted_ip
master_fd	sys-linux.c	/^static int master_fd = -1;$/;"	v	file:
match_option	options.c	/^match_option(name, opt, dowild)$/;"	f	file:
max_data_rate	tty.c	/^int	max_data_rate;		\/* max bytes\/sec through charshunt *\/$/;"	v
max_in_fd	sys-linux.c	/^static int max_in_fd;		\/* highest fd set in in_fds *\/$/;"	v	file:
max_transmits	chap.h	/^    int max_transmits;		\/* Maximum # of challenge transmissions *\/$/;"	m	struct:chap_state
maxconfreqtransmits	fsm.h	/^    int maxconfreqtransmits;	\/* Maximum Configure-Request transmissions *\/$/;"	m	struct:fsm
maxconnect	options.c	/^int	maxconnect = 0;		\/* Maximum connect time *\/$/;"	v
maxfail	options.c	/^int	maxfail = 10;		\/* max # of unsuccessful connection attempts *\/$/;"	v
maxnakloops	fsm.h	/^    int maxnakloops;		\/* Maximum number of nak loops tolerated *\/$/;"	m	struct:fsm
maxslotindex	ipcp.h	/^    int  maxslotindex;		\/* values for RFC1332 VJ compression neg. *\/$/;"	m	struct:ipcp_options
maxtermtransmits	fsm.h	/^    int maxtermtransmits;	\/* Maximum Terminate-Request transmissions *\/$/;"	m	struct:fsm
maybe_relock	tty.c	/^maybe_relock(arg, pid)$/;"	f	file:
method	ccp.h	/^    short method;		\/* code for chosen compression method *\/$/;"	m	struct:ccp_options
method_name	ccp.c	/^method_name(opt, opt2)$/;"	f	file:
minconnect	plugins/minconn.c	/^static int minconnect = 0;$/;"	v	file:
modem	tty.c	/^bool	modem = 1;		\/* Use modem control lines *\/$/;"	v
mp_check_options	multilink.c	/^mp_check_options()$/;"	f
mp_join_bundle	multilink.c	/^mp_join_bundle()$/;"	f
mrand48	magic.c	/^mrand48()$/;"	f
mrru	lcp.h	/^    int	 mrru;			\/* Value of MRRU, and multilink enable *\/$/;"	m	struct:lcp_options
mru	lcp.h	/^    int  mru;			\/* Value of MRU *\/$/;"	m	struct:lcp_options
ms_lanman	chap_ms.c	/^bool	ms_lanman = 0;    	\/* Use LanMan password instead of NT *\/$/;"	v
multilink	options.c	/^bool	multilink = 0;		\/* Enable multilink operation *\/$/;"	v
mux_dev_name	sys-solaris.c	/^static char *mux_dev_name = IP_DEV_NAME;$/;"	v	file:
mux_dev_name	sys-solaris.c	/^static char *mux_dev_name = UDP_DEV_NAME;$/;"	v	file:
my_get_idle	plugins/minconn.c	/^static int my_get_idle(struct ppp_idle *idle)$/;"	f	file:
my_options	plugins/minconn.c	/^static option_t my_options[] = {$/;"	v	file:
n_arguments	options.c	/^n_arguments(opt)$/;"	f	file:
n_children	main.c	/^static int n_children;		\/* # child processes still running *\/$/;"	v	file:
n_children	main.old.c	/^static int n_children;		\/* # child processes still running *\/$/;"	v	file:
n_pollfds	sys-solaris.c	/^static int n_pollfds;$/;"	v	file:
n_pollfds	sys-sunos4.c	/^static int n_pollfds;$/;"	v	file:
nak_buffer	lcp.c	/^static u_char nak_buffer[PPP_MRU];	\/* where we construct a nak packet *\/$/;"	v	file:
nakci	fsm.h	/^    int  (*nakci)		\/* NAK our Configuration Information *\/$/;"	m	struct:fsm_callbacks
nakloops	fsm.h	/^    int nakloops;		\/* Number of nak loops since last ack *\/$/;"	m	struct:fsm
name	ipxcp.h	/^    u_char name [48];		\/* name of the router *\/$/;"	m	struct:ipxcp_options
name	main.c	/^    const char	*name;$/;"	m	struct:protocol_list	file:
name	main.old.c	/^    const char	*name;$/;"	m	struct:protocol_list	file:
name	pppd.h	/^	char	*name;		\/* name of the option *\/$/;"	m	struct:
name	pppd.h	/^    char *name;			\/* Text name of protocol *\/$/;"	m	struct:protent
name	tdb.h	/^	char *name; \/* the name of the database *\/$/;"	m	struct:
need_holdoff	main.c	/^int need_holdoff;		\/* need holdoff period before restarting *\/$/;"	v
need_holdoff	main.old.c	/^int need_holdoff;		\/* need holdoff period before restarting *\/$/;"	v
neg_accompression	lcp.h	/^    bool neg_accompression;	\/* HDLC Address\/Control Field Compression? *\/$/;"	m	struct:lcp_options
neg_addr	ipcp.h	/^    bool neg_addr;		\/* Negotiate IP Address? *\/$/;"	m	struct:ipcp_options
neg_asyncmap	lcp.h	/^    bool neg_asyncmap;		\/* Negotiate the async map? *\/$/;"	m	struct:lcp_options
neg_cbcp	lcp.h	/^    bool neg_cbcp;		\/* Negotiate use of CBCP *\/$/;"	m	struct:lcp_options
neg_chap	lcp.h	/^    bool neg_chap;		\/* Ask for CHAP authentication? *\/$/;"	m	struct:lcp_options
neg_complete	ipxcp.h	/^    bool neg_complete;		\/* Negotiate completion *\/$/;"	m	struct:ipxcp_options
neg_endpoint	lcp.h	/^    bool neg_endpoint;		\/* negotiate endpoint discriminator *\/$/;"	m	struct:lcp_options
neg_ifaceid	ipv6cp.h	/^    int neg_ifaceid;		\/* Negotiate interface identifier? *\/$/;"	m	struct:ipv6cp_options
neg_lqr	lcp.h	/^    bool neg_lqr;		\/* Negotiate use of Link Quality Reports *\/$/;"	m	struct:lcp_options
neg_magicnumber	lcp.h	/^    bool neg_magicnumber;	\/* Ask for magic number? *\/$/;"	m	struct:lcp_options
neg_mrru	lcp.h	/^    bool neg_mrru;		\/* negotiate multilink MRRU *\/$/;"	m	struct:lcp_options
neg_mru	lcp.h	/^    bool neg_mru;		\/* Negotiate the MRU? *\/$/;"	m	struct:lcp_options
neg_name	ipxcp.h	/^    bool neg_name;		\/* Negotiate IPX router name *\/$/;"	m	struct:ipxcp_options
neg_nn	ipxcp.h	/^    bool neg_nn;		\/* Negotiate IPX network number? *\/$/;"	m	struct:ipxcp_options
neg_node	ipxcp.h	/^    bool neg_node;		\/* Negotiate IPX node number? *\/$/;"	m	struct:ipxcp_options
neg_pcompression	lcp.h	/^    bool neg_pcompression;	\/* HDLC Protocol Field Compression? *\/$/;"	m	struct:lcp_options
neg_router	ipxcp.h	/^    bool neg_router;		\/* Negotiate IPX router number *\/$/;"	m	struct:ipxcp_options
neg_ssnhf	lcp.h	/^    bool neg_ssnhf;		\/* negotiate short sequence numbers *\/$/;"	m	struct:lcp_options
neg_upap	lcp.h	/^    bool neg_upap;		\/* Ask for UPAP authentication? *\/$/;"	m	struct:lcp_options
neg_vj	ipcp.h	/^    bool neg_vj;		\/* Van Jacobson Compression? *\/$/;"	m	struct:ipcp_options
neg_vj	ipv6cp.h	/^    int neg_vj;			\/* Van Jacobson Compression? *\/$/;"	m	struct:ipv6cp_options
net_short	ipcp.c	2024;"	d	file:
netif_set_mtu	sys-linux.c	/^netif_set_mtu(int unit, int mtu)$/;"	f
netif_set_mtu	sys-solaris.c	/^netif_set_mtu(unit, mtu)$/;"	f
netmask	ipcp.c	/^u_int32_t netmask = 0;		\/* IP netmask to set on interface *\/$/;"	v
netmask_str	ipcp.c	/^static char netmask_str[20];		\/* string form of netmask value *\/$/;"	v	file:
network	ipxcp.h	/^    u_int32_t network;		\/* the final network number *\/$/;"	m	struct:ipxcp_options
network_phase	auth.c	/^network_phase(unit)$/;"	f	file:
new_phase	main.c	/^new_phase(p)$/;"	f
new_phase	main.old.c	/^new_phase(p)$/;"	f
new_phase_hook	main.c	/^int (*new_phase_hook) __P((int)) = NULL;$/;"	v
new_phase_hook	main.old.c	/^int (*new_phase_hook) __P((int)) = NULL;$/;"	v
new_style_driver	sys-linux.c	/^static int new_style_driver = 0;$/;"	v	file:
next	demand.c	/^    struct packet *next;$/;"	m	struct:packet	file:
next	main.c	/^    struct subprocess *next;$/;"	m	struct:subprocess	file:
next	main.old.c	/^    struct subprocess *next;$/;"	m	struct:subprocess	file:
next	options.c	/^    struct option_list *next;$/;"	m	struct:option_list	file:
next	options.c	/^    struct option_value *next;$/;"	m	struct:option_value	file:
next	pppd.h	/^    struct notifier *next;$/;"	m	struct:notifier
next	pppd.h	/^    struct wordlist	*next;$/;"	m	struct:wordlist
next	tdb.c	/^	tdb_off next; \/* offset of the next record in the list *\/$/;"	m	struct:list_struct	file:
ngroups	main.c	/^int ngroups;			\/* How many groups valid in groups *\/$/;"	v
ngroups	main.old.c	/^int ngroups;			\/* How many groups valid in groups *\/$/;"	v
no_ifaceid_neg	ipv6cp.c	/^int no_ifaceid_neg = 0;$/;"	v
no_ppp_msg	main.c	/^char *no_ppp_msg = "Sorry - this system lacks PPP kernel support\\n";$/;"	v
no_ppp_msg	main.old.c	/^char *no_ppp_msg = "Sorry - this system lacks PPP kernel support\\n";$/;"	v
noauth_addrs	auth.c	/^static struct wordlist *noauth_addrs;$/;"	v	file:
nodetach	options.c	/^bool	nodetach = 0;		\/* Don't detach from controlling tty *\/$/;"	v
noendpoint	lcp.c	/^bool	noendpoint = 0;		\/* don't send\/accept endpoint discriminator *\/$/;"	v
noopt	lcp.c	/^noopt(argv)$/;"	f	file:
notice	utils.c	/^notice __V((char *fmt, ...))$/;"	f
notifier	pppd.h	/^struct notifier {$/;"	s
notify	main.c	/^notify(notif, val)$/;"	f
notify	main.old.c	/^notify(notif, val)$/;"	f
notify_func	pppd.h	/^typedef void (*notify_func) __P((void *, int));$/;"	t
notty	tty.c	/^bool	notty = 0;		\/* Stdin\/out is not a tty *\/$/;"	v
novm	main.c	/^novm(msg)$/;"	f
novm	main.old.c	/^novm(msg)$/;"	f
np_down	auth.c	/^np_down(unit, proto)$/;"	f
np_finished	auth.c	/^np_finished(unit, proto)$/;"	f
np_up	auth.c	/^np_up(unit, proto)$/;"	f
null_data	tdb.c	/^static TDB_DATA null_data;$/;"	v	file:
null_login	auth.c	/^null_login(unit)$/;"	f	file:
num_np_open	auth.c	/^static int num_np_open;$/;"	v	file:
num_np_up	auth.c	/^static int num_np_up;$/;"	v	file:
number_option	options.c	/^number_option(str, valp, base)$/;"	f	file:
numloops	lcp.h	/^    int  numloops;		\/* Number of loops during magic number neg. *\/$/;"	m	struct:lcp_options
o_bool	pppd.h	/^	o_bool,$/;"	e	enum:opt_type
o_int	pppd.h	/^	o_int,$/;"	e	enum:opt_type
o_special	pppd.h	/^	o_special = 1,$/;"	e	enum:opt_type
o_special_noarg	pppd.h	/^	o_special_noarg = 0,$/;"	e	enum:opt_type
o_string	pppd.h	/^	o_string,$/;"	e	enum:opt_type
o_uint32	pppd.h	/^	o_uint32,$/;"	e	enum:opt_type
o_wild	pppd.h	/^	o_wild,$/;"	e	enum:opt_type
ofs_read	tdb.c	/^static int ofs_read(TDB_CONTEXT *tdb, tdb_off offset, tdb_off *d)$/;"	f	file:
ofs_write	tdb.c	/^static int ofs_write(TDB_CONTEXT *tdb, tdb_off offset, tdb_off *d)$/;"	f	file:
ok_error	sys-linux.c	118;"	d	file:
old_addrs	ipcp.h	/^    bool old_addrs;		\/* Use old (IP-Addresses) option? *\/$/;"	m	struct:ipcp_options
old_vj	ipcp.h	/^    bool old_vj;		\/* use old (short) form of VJ option? *\/$/;"	m	struct:ipcp_options
open	pppd.h	/^    void (*open) __P((int unit));$/;"	m	struct:protent
open_ccp	main.c	/^open_ccp(sig)$/;"	f	file:
open_ccp	main.old.c	/^open_ccp(sig)$/;"	f	file:
open_ccp_flag	main.c	/^int open_ccp_flag;$/;"	v
open_ccp_flag	main.old.c	/^int open_ccp_flag;$/;"	v
open_ppp_loopback	sys-linux.c	/^open_ppp_loopback(void)$/;"	f
open_ppp_loopback	sys-solaris.c	/^open_ppp_loopback()$/;"	f
open_ppp_loopback	sys-sunos4.c	/^open_ppp_loopback()$/;"	f
open_route_table	sys-linux.c	/^static int open_route_table (void)$/;"	f	file:
open_socket	tty.c	/^open_socket(dest)$/;"	f	file:
opt_local	ipv6cp.h	/^    int opt_local;		\/* ourtoken set by option *\/$/;"	m	struct:ipv6cp_options
opt_remote	ipv6cp.h	/^    int opt_remote;		\/* histoken set by option *\/$/;"	m	struct:ipv6cp_options
opt_type	pppd.h	/^enum opt_type {$/;"	g
option_error	options.c	/^option_error __V((char *fmt, ...))$/;"	f
option_list	options.c	/^struct option_list {$/;"	s	file:
option_priority	options.c	/^int  option_priority = OPRIO_CFGFILE; \/* priority of the current options *\/$/;"	v
option_source	options.c	/^char *option_source;		\/* string saying where the option came from *\/$/;"	v
option_t	pppd.h	/^} option_t;$/;"	t
option_value	options.c	/^struct option_value {$/;"	s	file:
options	options.c	/^    option_t *options;$/;"	m	struct:option_list	file:
options	plugins/passprompt.c	/^static option_t options[] = {$/;"	v	file:
options	pppd.h	/^	option_t *options;$/;"	m	struct:channel
options	pppd.h	/^    option_t *options;		\/* List of command-line options *\/$/;"	m	struct:protent
options_for_tty	options.c	/^options_for_tty()$/;"	f
options_from_file	options.c	/^options_from_file(filename, must_exist, check_prot, priv)$/;"	f
options_from_list	options.c	/^options_from_list(w, priv)$/;"	f
options_from_user	options.c	/^options_from_user()$/;"	f
our_name	options.c	/^char	our_name[MAXNAMELEN];	\/* Our name for authentication purposes *\/$/;"	v
our_network	ipxcp.h	/^    u_int32_t our_network;	\/* our value for network number *\/$/;"	m	struct:ipxcp_options
our_node	ipxcp.h	/^    u_char our_node[6];		\/* our node number *\/$/;"	m	struct:ipxcp_options
our_old_addr	sys-linux.c	/^static u_int32_t our_old_addr;		\/* for detecting address changes *\/$/;"	v	file:
ouraddr	ipcp.h	/^    u_int32_t ouraddr, hisaddr;	\/* Addresses in NETWORK BYTE ORDER *\/$/;"	m	struct:ipcp_options
ourid	ipv6cp.h	/^    eui64_t ourid, hisid;	\/* Interface identifiers *\/$/;"	m	struct:ipv6cp_options
outpacket_buf	main.c	/^u_char outpacket_buf[PPP_MRU+PPP_HDRLEN]; \/* buffer for outgoing packet *\/$/;"	v
outpacket_buf	main.old.c	/^u_char outpacket_buf[PPP_MRU+PPP_HDRLEN]; \/* buffer for outgoing packet *\/$/;"	v
output	sys-linux.c	/^void output (int unit, unsigned char *p, int len)$/;"	f
output	sys-solaris.c	/^output(unit, p, len)$/;"	f
output	sys-sunos4.c	/^output(unit, p, len)$/;"	f
override_value	options.c	/^override_value(option, priority, source)$/;"	f
owns_unit	multilink.c	/^owns_unit(key, unit)$/;"	f	file:
packet	demand.c	/^struct packet {$/;"	s	file:
pamh	auth.c	/^static pam_handle_t *pamh = NULL;$/;"	v	file:
pap_auth_hook	auth.c	/^int (*pap_auth_hook) __P((char *user, char *passwd, char **msgp,$/;"	v
pap_check_hook	auth.c	/^int (*pap_check_hook) __P((void)) = NULL;$/;"	v
pap_logout_hook	auth.c	/^void (*pap_logout_hook) __P((void)) = NULL;$/;"	v
pap_option_list	upap.c	/^static option_t pap_option_list[] = {$/;"	v	file:
pap_passwd_hook	auth.c	/^int (*pap_passwd_hook) __P((char *user, char *passwd)) = NULL;$/;"	v
pap_protent	upap.c	/^struct protent pap_protent = {$/;"	v
parent_pid	sys-sunos4.c	/^static pid_t	parent_pid;	\/* PID of our parent *\/$/;"	v	file:
parse_args	options.c	/^parse_args(argc, argv)$/;"	f
parse_dotted_ip	ipcp.c	/^parse_dotted_ip(p, vp)$/;"	f
parse_num	multilink.c	/^parse_num(str, key, valp)$/;"	f	file:
pass_filter	options.c	/^struct	bpf_program pass_filter;\/* Filter program for packets to pass *\/$/;"	v
passive	lcp.h	/^    bool passive;		\/* Don't die if we don't get a response *\/$/;"	m	struct:lcp_options
passwd	options.c	/^char	passwd[MAXSECRETLEN];	\/* Password for PAP *\/$/;"	v
passwd_from_file	auth.c	/^static int passwd_from_file;$/;"	v	file:
path_to_procfs	sys-linux.c	/^static char *path_to_procfs(const char *tail)$/;"	f	file:
pc	options.c	/^pcap_t  pc;			\/* Fake struct pcap so we can compile expr *\/$/;"	v
peer_authname	auth.c	/^char peer_authname[MAXNAMELEN];$/;"	v
peer_mru	fsm.c	/^int peer_mru[NUM_PPP];$/;"	v
pend_q	demand.c	/^struct packet *pend_q;$/;"	v
pend_qtail	demand.c	/^struct packet *pend_qtail;$/;"	v
permit	pppd.h	/^    int		permit;		\/* 1 = permit, 0 = forbid *\/$/;"	m	struct:permitted_ip
permitted_ip	pppd.h	/^struct permitted_ip {$/;"	s
persist	options.c	/^bool	persist = 0;		\/* Reopen link after it goes down *\/$/;"	v
phase	main.c	/^int phase;			\/* where the link is at *\/$/;"	v
phase	main.old.c	/^int phase;			\/* where the link is at *\/$/;"	v
phasechange	main.c	/^struct notifier *phasechange = NULL;$/;"	v
phasechange	main.old.c	/^struct notifier *phasechange = NULL;$/;"	v
pid	main.c	/^    pid_t	pid;$/;"	m	struct:subprocess	file:
pid	main.old.c	/^    pid_t	pid;$/;"	m	struct:subprocess	file:
pidchange	main.c	/^struct notifier *pidchange = NULL;$/;"	v
pidchange	main.old.c	/^struct notifier *pidchange = NULL;$/;"	v
pidfilename	main.c	/^static char pidfilename[MAXPATHLEN];	\/* name of pid file *\/$/;"	v	file:
pidfilename	main.old.c	/^static char pidfilename[MAXPATHLEN];	\/* name of pid file *\/$/;"	v	file:
plogin	auth.c	/^plogin(user, passwd, msg)$/;"	f	file:
plogout	auth.c	/^plogout()$/;"	f	file:
plugin_init	plugins/minconn.c	/^void plugin_init(void)$/;"	f
plugin_init	plugins/passprompt.c	/^void plugin_init(void)$/;"	f
pollfds	sys-solaris.c	/^static struct pollfd pollfds[MAX_POLLFDS];$/;"	v	file:
pollfds	sys-sunos4.c	/^static struct pollfd pollfds[MAX_POLLFDS];$/;"	v	file:
ppp_available	sys-linux.c	/^int ppp_available(void)$/;"	f
ppp_available	sys-solaris.c	/^ppp_available()$/;"	f
ppp_available	sys-sunos4.c	/^ppp_available()$/;"	f
ppp_dev_fd	sys-linux.c	/^static int ppp_dev_fd = -1;	\/* fd for \/dev\/ppp (new style driver) *\/$/;"	v	file:
ppp_devnam	main.c	/^char ppp_devnam[MAXPATHLEN];	\/* name of PPP tty (maybe ttypx) *\/$/;"	v
ppp_devnam	main.old.c	/^char ppp_devnam[MAXPATHLEN];	\/* name of PPP tty (maybe ttypx) *\/$/;"	v
ppp_disc	sys-linux.c	/^static int ppp_disc = N_PPP;	\/* The PPP discpline *\/$/;"	v	file:
ppp_fd	sys-linux.c	/^static int ppp_fd = -1;		\/* fd which is set to PPP discipline *\/$/;"	v	file:
ppp_recv_config	pppd.h	388;"	d
ppp_recv_config	sys-sunos4.c	/^ppp_recv_config(unit, mru, asyncmap, pcomp, accomp)$/;"	f
ppp_registered	sys-linux.c	/^ppp_registered(void)$/;"	f	file:
ppp_send_config	pppd.h	382;"	d
ppp_send_config	sys-sunos4.c	/^ppp_send_config(unit, mtu, asyncmap, pcomp, accomp)$/;"	f
ppp_set_xaccm	sys-sunos4.c	/^ppp_set_xaccm(unit, accm)$/;"	f
pppd_stats	pppd.h	/^struct pppd_stats {$/;"	s
pppd_version	plugins/minconn.c	/^char pppd_version[] = VERSION;$/;"	v
pppd_version	plugins/passprompt.c	/^char pppd_version[] = VERSION;$/;"	v
pppdb	main.c	/^TDB_CONTEXT *pppdb;		\/* database for storing status etc. *\/$/;"	v
pppdb	main.old.c	/^TDB_CONTEXT *pppdb;		\/* database for storing status etc. *\/$/;"	v
pppfd	sys-solaris.c	/^static int	pppfd;$/;"	v	file:
pppfd	sys-sunos4.c	/^static int	pppfd;$/;"	v	file:
pr_log	utils.c	/^pr_log __V((void *arg, char *fmt, ...))$/;"	f
predictor_1	ccp.h	/^    bool predictor_1;		\/* do Predictor-1? *\/$/;"	m	struct:ccp_options
predictor_2	ccp.h	/^    bool predictor_2;		\/* do Predictor-2? *\/$/;"	m	struct:ccp_options
print_option	options.c	/^print_option(opt, mainopt, printer, arg)$/;"	f	file:
print_option_list	options.c	/^print_option_list(opt, printer, arg)$/;"	f	file:
print_options	options.c	/^print_options(printer, arg)$/;"	f
print_string	utils.c	/^print_string(p, len, printer, arg)$/;"	f
printendpoint	lcp.c	/^printendpoint(opt, printer, arg)$/;"	f	file:
printescape	tty.c	/^printescape(opt, printer, arg)$/;"	f	file:
printifaceid	ipv6cp.c	/^printifaceid(opt, printer, arg)$/;"	f	file:
printipaddr	ipcp.c	/^printipaddr(opt, printer, arg)$/;"	f	file:
printipxnode	ipxcp.c	/^printipxnode(opt, printer, arg)$/;"	f	file:
printpkt	pppd.h	/^    int  (*printpkt) __P((u_char *pkt, int len,$/;"	m	struct:protent
priority	pppd.h	/^	short int priority;$/;"	m	struct:
privgroup	auth.c	/^privgroup(argv)$/;"	f	file:
privileged	main.c	/^int privileged;			\/* we're running as real uid root *\/$/;"	v
privileged	main.old.c	/^int privileged;			\/* we're running as real uid root *\/$/;"	v
privileged_option	options.c	/^int  privileged_option;		\/* set iff the current option came from root *\/$/;"	v
privopen	main.c	/^int privopen;			\/* don't lock, open device as root *\/$/;"	v
privopen	main.old.c	/^int privopen;			\/* don't lock, open device as root *\/$/;"	v
proc_path	sys-linux.c	/^static char proc_path[MAXPATHLEN];$/;"	v	file:
proc_path_len	sys-linux.c	/^static int proc_path_len;$/;"	v	file:
process_exists	multilink.c	52;"	d	file:
process_extra_options	pppd.h	/^	void (*process_extra_options) __P((void));$/;"	m	struct:channel
process_option	options.c	/^process_option(opt, cmd, argv)$/;"	f	file:
prog	main.c	/^    char	*prog;$/;"	m	struct:subprocess	file:
prog	main.old.c	/^    char	*prog;$/;"	m	struct:subprocess	file:
progname	main.c	/^char *progname;			\/* Name of this program *\/$/;"	v
progname	main.old.c	/^char *progname;			\/* Name of this program *\/$/;"	v
promptpass	plugins/passprompt.c	/^static int promptpass(char *user, char *passwd)$/;"	f	file:
promptprog	plugins/passprompt.c	/^static char promptprog[PATH_MAX+1];$/;"	v	file:
protent	pppd.h	/^struct protent {$/;"	s
proto	main.c	/^    u_short	proto;$/;"	m	struct:protocol_list	file:
proto	main.old.c	/^    u_short	proto;$/;"	m	struct:protocol_list	file:
proto_name	fsm.h	/^    char *proto_name;		\/* String name for protocol (for messages) *\/$/;"	m	struct:fsm_callbacks
protocol	fsm.h	/^    int protocol;		\/* Data Link Layer Protocol field value *\/$/;"	m	struct:fsm
protocol	pppd.h	/^    u_short protocol;		\/* PPP protocol number *\/$/;"	m	struct:protent
protocol_list	main.c	/^struct protocol_list {$/;"	s	file:
protocol_list	main.c	/^} protocol_list[] = {$/;"	v
protocol_list	main.old.c	/^struct protocol_list {$/;"	s	file:
protocol_list	main.old.c	/^} protocol_list[] = {$/;"	v
protocol_name	main.c	/^protocol_name(proto)$/;"	f
protocol_name	main.old.c	/^protocol_name(proto)$/;"	f
protocols	main.c	/^struct protent *protocols[] = {$/;"	v
protocols	main.old.c	/^struct protent *protocols[] = {$/;"	v
protrej	pppd.h	/^    void (*protrej) __P((int unit));$/;"	m	struct:protent
protreject	fsm.h	/^    void (*protreject)		\/* Called when Protocol-Reject received *\/$/;"	m	struct:fsm_callbacks
proxy_arp	ipcp.h	/^    bool proxy_arp;		\/* Make proxy ARP entry for peer? *\/$/;"	m	struct:ipcp_options
proxy_arp_addr	sys-linux.c	/^static u_int32_t proxy_arp_addr;	\/* Addr for proxy arp entry added *\/$/;"	v	file:
proxy_arp_addr	sys-solaris.c	/^static u_int32_t proxy_arp_addr;	\/* Addr for proxy arp entry added *\/$/;"	v	file:
proxy_arp_addr	sys-sunos4.c	/^static u_int32_t proxy_arp_addr;	\/* Addr for proxy arp entry added *\/$/;"	v	file:
proxy_arp_dev	sys-linux.c	/^static char proxy_arp_dev[16];		\/* Device for proxy arp entry *\/$/;"	v	file:
proxy_arp_set	ipcp.c	/^static int proxy_arp_set[NUM_PPP];	\/* Have created proxy arp entry *\/$/;"	v	file:
ptr	utils.c	/^    char *ptr;$/;"	m	struct:buffer_info	file:
pty_master	tty.c	/^static int pty_master;		\/* fd for master side of pty *\/$/;"	v	file:
pty_slave	tty.c	/^static int pty_slave;		\/* fd for slave side of pty *\/$/;"	v	file:
pty_socket	tty.c	/^char	*pty_socket = NULL;	\/* Socket to connect to pty *\/$/;"	v
ptycommand	tty.c	/^char	*ptycommand = NULL;	\/* Command to run on other side of pty *\/$/;"	v
rcsid	auth.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	cbcp.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	ccp.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	chap.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	chap_ms.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	demand.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	eui64.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	fsm.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	ipcp.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	ipv6cp.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	ipxcp.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	lcp.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	magic.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	main.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	main.old.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	options.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	sys-solaris.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	sys-sunos4.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	upap.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
rcsid	utils.c	/^static const char rcsid[] = RCSID;$/;"	v	file:
read_only	tdb.h	/^	int read_only; \/* opened read-only *\/$/;"	m	struct:
read_packet	sys-linux.c	/^int read_packet (unsigned char *buf)$/;"	f
read_packet	sys-solaris.c	/^read_packet(buf)$/;"	f
read_packet	sys-sunos4.c	/^read_packet(buf)$/;"	f
read_route_table	sys-linux.c	/^static int read_route_table(struct rtentry *rt)$/;"	f	file:
readfile	options.c	/^readfile(argv)$/;"	f	file:
real_ttyfd	tty.c	/^static int real_ttyfd;		\/* fd for actual serial port (not pty) *\/$/;"	v	file:
reap_kids	main.c	/^reap_kids(waitfor)$/;"	f	file:
reap_kids	main.old.c	/^reap_kids(waitfor)$/;"	f	file:
rec_len	tdb.c	/^	tdb_len rec_len; \/* total byte length of record *\/$/;"	m	struct:list_struct	file:
rec_read	tdb.c	/^static int rec_read(TDB_CONTEXT *tdb, tdb_off offset, struct list_struct *rec)$/;"	f	file:
rec_write	tdb.c	/^static int rec_write(TDB_CONTEXT *tdb, tdb_off offset, struct list_struct *rec)$/;"	f	file:
record_child	main.c	/^record_child(pid, prog, done, arg)$/;"	f
record_child	main.old.c	/^record_child(pid, prog, done, arg)$/;"	f
record_file	tty.c	/^char	*record_file = NULL;	\/* File to record chars sent\/received *\/$/;"	v
record_write	tty.c	/^record_write(f, code, buf, nb, tp)$/;"	f	file:
recv_config	pppd.h	/^	void (*recv_config) __P((int, u_int32_t, int, int));$/;"	m	struct:channel
refuse_chap	auth.c	/^bool refuse_chap = 0;		\/* Don't wanna auth. ourselves with CHAP *\/$/;"	v
refuse_pap	auth.c	/^bool refuse_pap = 0;		\/* Don't wanna auth. ourselves with PAP *\/$/;"	v
rejci	fsm.h	/^    int  (*rejci)		\/* Reject our Configuration Information *\/$/;"	m	struct:fsm_callbacks
relock	utils.c	/^relock(pid)$/;"	f
remote_addr	sys-solaris.c	/^static u_int32_t remote_addr;		\/* IP address of peer *\/$/;"	v	file:
remote_name	auth.c	/^char remote_name[MAXNAMELEN];	\/* Peer's name for authentication *\/$/;"	v
remove_fd	sys-linux.c	/^void remove_fd(int fd)$/;"	f
remove_fd	sys-solaris.c	/^void remove_fd(fd)$/;"	f
remove_fd	sys-sunos4.c	/^void remove_fd(fd)$/;"	f
remove_notifier	main.c	/^remove_notifier(notif, func, arg)$/;"	f
remove_notifier	main.old.c	/^remove_notifier(notif, func, arg)$/;"	f
reopen_log	main.c	/^reopen_log()$/;"	f
reopen_log	main.old.c	/^reopen_log()$/;"	f
req_addr	ipcp.h	/^    bool req_addr;		\/* Ask peer to send IP address? *\/$/;"	m	struct:ipcp_options
req_dns1	ipcp.h	/^    bool req_dns1;		\/* Ask peer to send primary DNS address? *\/$/;"	m	struct:ipcp_options
req_dns2	ipcp.h	/^    bool req_dns2;		\/* Ask peer to send secondary DNS address? *\/$/;"	m	struct:ipcp_options
req_ifaceid	ipv6cp.h	/^    int req_ifaceid;		\/* Ask peer to send interface identifier? *\/$/;"	m	struct:ipv6cp_options
req_nn	ipxcp.h	/^    bool req_nn;		\/* Ask peer to send IPX network number *\/$/;"	m	struct:ipxcp_options
req_node	ipxcp.h	/^    bool req_node;		\/* Ask peer to send IPX node number? *\/$/;"	m	struct:ipxcp_options
req_unit	options.c	/^int	req_unit = -1;		\/* requested interface unit *\/$/;"	v
reqci	fsm.h	/^    int  (*reqci)		\/* Request peer's Configuration Information *\/$/;"	m	struct:fsm_callbacks
reqid	fsm.h	/^    u_char reqid;		\/* Current request id *\/$/;"	m	struct:fsm
resetci	fsm.h	/^    void (*resetci)		\/* Reset our Configuration Information *\/$/;"	m	struct:fsm_callbacks
resp_id	chap.h	/^    u_char resp_id;		\/* ID for response messages *\/$/;"	m	struct:chap_state
resp_length	chap.h	/^    u_char resp_length;		\/* length of response *\/$/;"	m	struct:chap_state
resp_name	chap.h	/^    char *resp_name;		\/* Our name to send with response *\/$/;"	m	struct:chap_state
resp_transmits	chap.h	/^    int resp_transmits;		\/* Number of transmissions of response *\/$/;"	m	struct:chap_state
resp_type	chap.h	/^    u_char resp_type;		\/* hash algorithm for responses *\/$/;"	m	struct:chap_state
response	chap.h	/^    u_char response[MAX_RESPONSE_LENGTH];	\/* Response to send *\/$/;"	m	struct:chap_state
restart	lcp.h	/^    bool restart;		\/* Restart vs. exit after close *\/$/;"	m	struct:lcp_options
restore_loop	sys-linux.c	/^restore_loop(void)$/;"	f	file:
restore_term	sys-linux.c	/^static int restore_term        = 0;	\/* 1 => we've munged the terminal *\/$/;"	v	file:
restore_term	sys-solaris.c	/^static int	restore_term;$/;"	v	file:
restore_term	sys-sunos4.c	/^static int	restore_term;$/;"	v	file:
restore_tty	sys-linux.c	/^void restore_tty (int tty_fd)$/;"	f
restore_tty	sys-solaris.c	/^restore_tty(fd)$/;"	f
restore_tty	sys-sunos4.c	/^restore_tty(fd)$/;"	f
retransmit	fsm.h	/^    void (*retransmit)		\/* Retransmission is necessary *\/$/;"	m	struct:fsm_callbacks
retransmits	fsm.h	/^    int retransmits;		\/* Number of retransmissions left *\/$/;"	m	struct:fsm
rot	md4.c	77;"	d	file:
route_buffer	sys-linux.c	/^static char route_buffer[512];$/;"	v	file:
route_delims	sys-linux.c	/^static char route_delims[] = " \\t\\n";$/;"	v	file:
route_dest_col	sys-linux.c	/^static int route_dev_col, route_dest_col, route_gw_col;$/;"	v	file:
route_dev_col	sys-linux.c	/^static int route_dev_col, route_dest_col, route_gw_col;$/;"	v	file:
route_fd	sys-linux.c	/^FILE *route_fd = (FILE *) 0;$/;"	v
route_flags_col	sys-linux.c	/^static int route_flags_col, route_mask_col;$/;"	v	file:
route_gw_col	sys-linux.c	/^static int route_dev_col, route_dest_col, route_gw_col;$/;"	v	file:
route_mask_col	sys-linux.c	/^static int route_flags_col, route_mask_col;$/;"	v	file:
route_num_cols	sys-linux.c	/^static int route_num_cols;$/;"	v	file:
router	ipxcp.h	/^    int    router;		\/* routing protocol *\/$/;"	m	struct:ipxcp_options
run_program	main.c	/^run_program(prog, args, must_exist, done, arg)$/;"	f
run_program	main.old.c	/^run_program(prog, args, must_exist, done, arg)$/;"	f
s6_addr32	eui64.h	41;"	d
s6_addr8	eui64.h	40;"	d
s_down	auth.c	/^    s_down,$/;"	e	enum:script_state	file:
s_down	ipcp.c	/^    s_down,$/;"	e	enum:script_state	file:
s_down	ipv6cp.c	/^    s_down,$/;"	e	enum:script_state	file:
s_env_nalloc	main.c	/^int s_env_nalloc;		\/* # words avail at script_env *\/$/;"	v
s_env_nalloc	main.old.c	/^int s_env_nalloc;		\/* # words avail at script_env *\/$/;"	v
s_up	auth.c	/^    s_up$/;"	e	enum:script_state	file:
s_up	ipcp.c	/^    s_up,$/;"	e	enum:script_state	file:
s_up	ipv6cp.c	/^    s_up,$/;"	e	enum:script_state	file:
scan_authfile	auth.c	/^scan_authfile(f, client, server, secret, addrs, opts, filename)$/;"	f	file:
script_env	main.c	/^char **script_env;		\/* Env. variable values for scripts *\/$/;"	v
script_env	main.old.c	/^char **script_env;		\/* Env. variable values for scripts *\/$/;"	v
script_setenv	main.c	/^script_setenv(var, value, iskey)$/;"	f
script_setenv	main.old.c	/^script_setenv(var, value, iskey)$/;"	f
script_state	auth.c	/^enum script_state {$/;"	g	file:
script_state	ipcp.c	/^static enum script_state {$/;"	g	file:
script_state	ipv6cp.c	/^static enum script_state {$/;"	g	file:
script_unsetenv	main.c	/^script_unsetenv(var)$/;"	f
script_unsetenv	main.old.c	/^script_unsetenv(var)$/;"	f
seen_ack	fsm.h	/^    u_char seen_ack;		\/* Have received valid Ack\/Nak\/Rej to Req *\/$/;"	m	struct:fsm
send_config	pppd.h	/^	void (*send_config) __P((int, u_int32_t, int, int));$/;"	m	struct:channel
serverstate	chap.h	/^    int serverstate;		\/* Server state *\/$/;"	m	struct:chap_state
set_allowed_addrs	auth.c	/^set_allowed_addrs(unit, addrs, opts)$/;"	f	file:
set_filters	sys-linux.c	/^int set_filters(struct bpf_program *pass, struct bpf_program *active)$/;"	f
set_flags	sys-linux.c	/^static void set_flags (int fd, int flags)$/;"	f	file:
set_ifunit	main.c	/^set_ifunit(iskey)$/;"	f
set_ifunit	main.old.c	/^set_ifunit(iskey)$/;"	f
set_ip_epdisc	multilink.c	39;"	d	file:
set_kdebugflag	sys-linux.c	/^static int set_kdebugflag (int requested_level)$/;"	f	file:
set_noauth_addr	auth.c	/^set_noauth_addr(argv)$/;"	f	file:
set_ppp_fd	sys-linux.c	/^static void set_ppp_fd (int new_fd)$/;"	f	file:
set_up_tty	sys-linux.c	/^void set_up_tty(int tty_fd, int local)$/;"	f
set_up_tty	sys-solaris.c	/^set_up_tty(fd, local)$/;"	f
set_up_tty	sys-sunos4.c	/^set_up_tty(fd, local)$/;"	f
setactivefilter	options.c	/^setactivefilter(argv)$/;"	f	file:
setbsdcomp	ccp.c	/^setbsdcomp(argv)$/;"	f	file:
setcbcp	cbcp.c	/^setcbcp(argv)$/;"	f	file:
setdeflate	ccp.c	/^setdeflate(argv)$/;"	f	file:
setdevname	tty.c	/^setdevname(cp, argv, doit)$/;"	f	file:
setdnsaddr	ipcp.c	/^setdnsaddr(argv)$/;"	f	file:
setdomain	options.c	/^setdomain(argv)$/;"	f	file:
setdtr	sys-linux.c	/^void setdtr (int tty_fd, int on)$/;"	f
setdtr	sys-solaris.c	/^setdtr(fd, on)$/;"	f
setdtr	sys-sunos4.c	/^setdtr(fd, on)$/;"	f
setendpoint	lcp.c	/^setendpoint(argv)$/;"	f	file:
setescape	tty.c	/^setescape(argv)$/;"	f	file:
setifaceid	ipv6cp.c	/^setifaceid(argv)$/;"	f	file:
setipaddr	ipcp.c	/^setipaddr(arg, argv, doit)$/;"	f	file:
setipxname	ipxcp.c	/^setipxname (argv)$/;"	f	file:
setipxnode	ipxcp.c	/^setipxnode(argv)$/;"	f	file:
setipxnodevalue	ipxcp.c	/^setipxnodevalue(src,dst)$/;"	f	file:
setlogfile	options.c	/^setlogfile(argv)$/;"	f	file:
setlogmask	main.c	189;"	d	file:
setlogmask	main.old.c	189;"	d	file:
setnetmask	ipcp.c	/^setnetmask(argv)$/;"	f	file:
setpassfilter	options.c	/^setpassfilter(argv)$/;"	f	file:
setspeed	tty.c	/^setspeed(arg, argv, doit)$/;"	f	file:
setup_signals	main.c	/^setup_signals()$/;"	f	file:
setup_signals	main.old.c	/^setup_signals()$/;"	f	file:
setupapfile	auth.c	/^setupapfile(argv)$/;"	f	file:
setvjslots	ipcp.c	/^setvjslots(argv)$/;"	f	file:
setwinsaddr	ipcp.c	/^setwinsaddr(argv)$/;"	f	file:
setxonxoff	tty.c	/^setxonxoff(argv)$/;"	f	file:
showhelp	options.c	/^showhelp(argv)$/;"	f	file:
showversion	options.c	/^showversion(argv)$/;"	f	file:
sif6addr	sys-linux.c	/^int sif6addr (int unit, eui64_t our_eui64, eui64_t his_eui64)$/;"	f
sif6addr	sys-solaris.c	/^sif6addr(u, o, h)$/;"	f
sif6down	sys-solaris.c	/^sif6down(u)$/;"	f
sif6up	sys-solaris.c	/^sif6up(u)$/;"	f
sifaddr	sys-linux.c	/^int sifaddr (int unit, u_int32_t our_adr, u_int32_t his_adr,$/;"	f
sifaddr	sys-solaris.c	/^sifaddr(u, o, h, m)$/;"	f
sifaddr	sys-sunos4.c	/^sifaddr(u, o, h, m)$/;"	f
sifdefaultroute	sys-linux.c	/^int sifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway)$/;"	f
sifdefaultroute	sys-solaris.c	/^sifdefaultroute(u, l, g)$/;"	f
sifdefaultroute	sys-sunos4.c	/^sifdefaultroute(u, l, g)$/;"	f
sifdown	sys-linux.c	/^int sifdown (int u)$/;"	f
sifdown	sys-solaris.c	/^sifdown(u)$/;"	f
sifdown	sys-sunos4.c	/^sifdown(u)$/;"	f
sifnpmode	sys-linux.c	/^sifnpmode(u, proto, mode)$/;"	f
sifnpmode	sys-solaris.c	/^sifnpmode(u, proto, mode)$/;"	f
sifnpmode	sys-sunos4.c	/^sifnpmode(u, proto, mode)$/;"	f
sifppa	sys-solaris.c	/^sifppa(fd, ppa)$/;"	f	file:
sifproxyarp	sys-linux.c	/^int sifproxyarp (int unit, u_int32_t his_adr)$/;"	f
sifproxyarp	sys-solaris.c	/^sifproxyarp(unit, hisaddr)$/;"	f
sifproxyarp	sys-sunos4.c	/^sifproxyarp(unit, hisaddr)$/;"	f
sifup	sys-linux.c	/^int sifup(int u)$/;"	f
sifup	sys-solaris.c	/^sifup(u)$/;"	f
sifup	sys-sunos4.c	/^sifup(u)$/;"	f
sifvjcomp	sys-linux.c	/^int sifvjcomp (int u, int vjcomp, int cidcomp, int maxcid)$/;"	f
sifvjcomp	sys-solaris.c	/^sifvjcomp(u, vjcomp, xcidcomp, xmaxcid)$/;"	f
sifvjcomp	sys-sunos4.c	/^sifvjcomp(u, vjcomp, xcidcomp, xmaxcid)$/;"	f
sigjmp	main.c	/^static sigjmp_buf sigjmp;$/;"	v	file:
sigjmp	main.old.c	/^static sigjmp_buf sigjmp;$/;"	v	file:
sigreceived	main.c	/^struct notifier *sigreceived = NULL;$/;"	v
sigreceived	main.old.c	/^struct notifier *sigreceived = NULL;$/;"	v
silent	lcp.h	/^    bool silent;		\/* Wait for the other end to start first *\/$/;"	m	struct:lcp_options
sipxfaddr	sys-linux.c	/^int sipxfaddr (int unit, unsigned long int network, unsigned char * node )$/;"	f
slave_fd	sys-linux.c	/^static int slave_fd = -1;$/;"	v	file:
slifname	sys-solaris.c	/^slifname(fd, ppa)$/;"	f	file:
slprintf	utils.c	/^slprintf __V((char *buf, int buflen, char *fmt, ...))$/;"	f
sock6_fd	sys-linux.c	/^static int sock6_fd = -1;$/;"	v	file:
sock_fd	sys-linux.c	/^static int sock_fd = -1;	\/* socket for doing interface ioctls *\/$/;"	v	file:
sockfd	sys-sunos4.c	/^static int	sockfd;$/;"	v	file:
some_ip_ok	auth.c	/^some_ip_ok(addrs)$/;"	f	file:
source	options.c	/^    const char *source;$/;"	m	struct:option_value	file:
source	pppd.h	/^	const char *source;$/;"	m	struct:
speed	sys-linux.c	/^struct speed {$/;"	s	file:
speed	sys-solaris.c	/^struct speed {$/;"	s	file:
speed	sys-sunos4.c	/^struct speed {$/;"	s	file:
speed_int	sys-linux.c	/^    int speed_int, speed_val;$/;"	m	struct:speed	file:
speed_int	sys-solaris.c	/^    int speed_int, speed_val;$/;"	m	struct:speed	file:
speed_int	sys-sunos4.c	/^    int speed_int, speed_val;$/;"	m	struct:speed	file:
speed_str	tty.c	/^static char speed_str[16];	\/* Serial port speed as string *\/$/;"	v	file:
speed_val	sys-linux.c	/^    int speed_int, speed_val;$/;"	m	struct:speed	file:
speed_val	sys-solaris.c	/^    int speed_int, speed_val;$/;"	m	struct:speed	file:
speed_val	sys-sunos4.c	/^    int speed_int, speed_val;$/;"	m	struct:speed	file:
speeds	sys-linux.c	/^} speeds[] = {$/;"	v
speeds	sys-solaris.c	/^} speeds[] = {$/;"	v
speeds	sys-sunos4.c	/^} speeds[] = {$/;"	v
srand48	magic.c	/^srand48(seedval)$/;"	f
start_charshunt	tty.c	/^start_charshunt(ifd, ofd)$/;"	f	file:
start_networks	auth.c	/^start_networks()$/;"	f
start_time	main.c	/^static struct timeval start_time;	\/* Time when link was started. *\/$/;"	v	file:
start_time	main.old.c	/^static struct timeval start_time;	\/* Time when link was started. *\/$/;"	v	file:
starting	fsm.h	/^    void (*starting)		\/* Called when we want the lower layer *\/$/;"	m	struct:fsm_callbacks
state	fsm.h	/^    int state;			\/* State *\/$/;"	m	struct:fsm
status	main.c	/^volatile int status;		\/* exit status for pppd *\/$/;"	v
status	main.old.c	/^volatile int status;		\/* exit status for pppd *\/$/;"	v
still_ppp	sys-linux.c	/^static int still_ppp(void)$/;"	f	file:
stop_charshunt	tty.c	/^stop_charshunt(arg, sig)$/;"	f	file:
str_to_epdisc	multilink.c	/^str_to_epdisc(ep, str)$/;"	f
strerror	sys-sunos4.c	/^strerror(n)$/;"	f
strioctl	sys-solaris.c	/^strioctl(fd, cmd, ptr, ilen, olen)$/;"	f	file:
strioctl	sys-sunos4.c	/^strioctl(fd, cmd, ptr, ilen, olen)$/;"	f	file:
strlcat	utils.c	/^strlcat(dest, src, len)$/;"	f
strlcpy	utils.c	/^strlcpy(dest, src, len)$/;"	f
strtoul	sys-sunos4.c	/^strtoul(str, ptr, base)$/;"	f
subprocess	main.c	/^struct subprocess {$/;"	s	file:
subprocess	main.old.c	/^struct subprocess {$/;"	s	file:
sync_serial	tty.c	/^bool	sync_serial = 0;	\/* Device is synchronous serial device *\/$/;"	v
sys_check_options	sys-linux.c	/^sys_check_options(void)$/;"	f
sys_check_options	sys-solaris.c	/^sys_check_options()$/;"	f
sys_check_options	sys-sunos4.c	/^sys_check_options()$/;"	f
sys_cleanup	sys-linux.c	/^void sys_cleanup(void)$/;"	f
sys_cleanup	sys-solaris.c	/^sys_cleanup()$/;"	f
sys_cleanup	sys-sunos4.c	/^sys_cleanup()$/;"	f
sys_close	sys-linux.c	/^sys_close(void)$/;"	f
sys_close	sys-solaris.c	/^sys_close()$/;"	f
sys_close	sys-sunos4.c	/^sys_close()$/;"	f
sys_init	sys-linux.c	/^void sys_init(void)$/;"	f
sys_init	sys-solaris.c	/^sys_init()$/;"	f
sys_init	sys-sunos4.c	/^sys_init()$/;"	f
tdb_alloc_read	tdb.c	/^static char *tdb_alloc_read(TDB_CONTEXT *tdb, tdb_off offset, tdb_len len)$/;"	f	file:
tdb_allocate	tdb.c	/^static tdb_off tdb_allocate(TDB_CONTEXT *tdb, tdb_len length)$/;"	f	file:
tdb_brlock	tdb.c	/^static int tdb_brlock(TDB_CONTEXT *tdb, tdb_off offset, $/;"	f	file:
tdb_close	tdb.c	/^int tdb_close(TDB_CONTEXT *tdb)$/;"	f
tdb_delete	tdb.c	/^int tdb_delete(TDB_CONTEXT *tdb, TDB_DATA key)$/;"	f
tdb_error	tdb.c	/^char *tdb_error(TDB_CONTEXT *tdb)$/;"	f
tdb_exists	tdb.c	/^int tdb_exists(TDB_CONTEXT *tdb, TDB_DATA key)$/;"	f
tdb_expand	tdb.c	/^static int tdb_expand(TDB_CONTEXT *tdb, tdb_off length)$/;"	f	file:
tdb_fetch	tdb.c	/^TDB_DATA tdb_fetch(TDB_CONTEXT *tdb, TDB_DATA key)$/;"	f
tdb_find	tdb.c	/^static tdb_off tdb_find(TDB_CONTEXT *tdb, TDB_DATA key, unsigned int hash,$/;"	f	file:
tdb_firstkey	tdb.c	/^TDB_DATA tdb_firstkey(TDB_CONTEXT *tdb)$/;"	f
tdb_hash	tdb.c	/^static unsigned tdb_hash(TDB_DATA *key)$/;"	f	file:
tdb_hash_top	tdb.c	/^static tdb_off tdb_hash_top(TDB_CONTEXT *tdb, unsigned hash)$/;"	f	file:
tdb_header	tdb.h	/^struct tdb_header {$/;"	s
tdb_len	tdb.h	/^typedef unsigned tdb_len;$/;"	t
tdb_lock	tdb.c	/^static int tdb_lock(TDB_CONTEXT *tdb, int list)$/;"	f	file:
tdb_lockchain	tdb.c	/^int tdb_lockchain(TDB_CONTEXT *tdb, TDB_DATA key)$/;"	f
tdb_new_database	tdb.c	/^static int tdb_new_database(TDB_CONTEXT *tdb, int hash_size)$/;"	f	file:
tdb_nextkey	tdb.c	/^TDB_DATA tdb_nextkey(TDB_CONTEXT *tdb, TDB_DATA key)$/;"	f
tdb_off	tdb.h	/^typedef unsigned tdb_off;$/;"	t
tdb_oob	tdb.c	/^static int tdb_oob(TDB_CONTEXT *tdb, tdb_off offset)$/;"	f	file:
tdb_open	tdb.c	/^TDB_CONTEXT *tdb_open(char *name, int hash_size, int tdb_flags,$/;"	f
tdb_read	tdb.c	/^static int tdb_read(TDB_CONTEXT *tdb, tdb_off offset, char *buf, tdb_len len)$/;"	f	file:
tdb_store	tdb.c	/^int tdb_store(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, int flag)$/;"	f
tdb_traverse	tdb.c	/^int tdb_traverse(TDB_CONTEXT *tdb, int (*fn)(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf, void* state), void* state)$/;"	f
tdb_unlock	tdb.c	/^static int tdb_unlock(TDB_CONTEXT *tdb, int list)$/;"	f	file:
tdb_unlockchain	tdb.c	/^int tdb_unlockchain(TDB_CONTEXT *tdb, TDB_DATA key)$/;"	f
tdb_update	tdb.c	/^int tdb_update(TDB_CONTEXT *tdb, TDB_DATA key, TDB_DATA dbuf)$/;"	f
tdb_write	tdb.c	/^static int tdb_write(TDB_CONTEXT *tdb, tdb_off offset, const char *buf, tdb_len len)$/;"	f	file:
tdb_writelock	tdb.c	/^int tdb_writelock(TDB_CONTEXT *tdb)$/;"	f
tdb_writeunlock	tdb.c	/^int tdb_writeunlock(TDB_CONTEXT *tdb)$/;"	f
term	main.c	/^term(sig)$/;"	f	file:
term	main.old.c	/^term(sig)$/;"	f	file:
term_reason	fsm.h	/^    char *term_reason;		\/* Reason for closing protocol *\/$/;"	m	struct:fsm
term_reason_len	fsm.h	/^    int term_reason_len;	\/* Length of term_reason *\/$/;"	m	struct:fsm
termiox_ok	sys-solaris.c	/^static int	termiox_ok;$/;"	v	file:
the_channel	main.c	/^struct channel *the_channel;$/;"	v
the_channel	main.old.c	/^struct channel *the_channel;$/;"	v
timeleft	main.c	/^timeleft(tvp)$/;"	f	file:
timeleft	main.old.c	/^timeleft(tvp)$/;"	f	file:
timenow	main.c	/^static struct timeval timenow;		\/* Current time *\/$/;"	v	file:
timenow	main.old.c	/^static struct timeval timenow;		\/* Current time *\/$/;"	v	file:
timeout	main.c	/^timeout(func, arg, secs, usecs)$/;"	f
timeout	main.old.c	/^timeout(func, arg, secs, usecs)$/;"	f
timeouttime	chap.h	/^    int timeouttime;		\/* Timeout time in seconds *\/$/;"	m	struct:chap_state
timeouttime	fsm.h	/^    int timeouttime;		\/* Timeout time in milliseconds *\/$/;"	m	struct:fsm
to_external	ipxcp.c	/^to_external(internal)$/;"	f	file:
toggle_debug	main.c	/^toggle_debug(sig)$/;"	f	file:
toggle_debug	main.old.c	/^toggle_debug(sig)$/;"	f	file:
translate_speed	sys-linux.c	/^static int translate_speed (int bps)$/;"	f	file:
translate_speed	sys-solaris.c	/^translate_speed(bps)$/;"	f	file:
translate_speed	sys-sunos4.c	/^translate_speed(bps)$/;"	f	file:
tried_nlsp	ipxcp.h	/^    bool tried_nlsp;		\/* I have suggested NLSP already *\/$/;"	m	struct:ipxcp_options
tried_rip	ipxcp.h	/^    bool tried_rip;		\/* I have suggested RIP\/SAP already *\/$/;"	m	struct:ipxcp_options
tty_channel	tty.c	/^struct channel tty_channel = {$/;"	v
tty_check_options	tty.c	/^tty_check_options()$/;"	f
tty_close_fds	tty.c	/^void tty_close_fds()$/;"	f
tty_disc	sys-linux.c	/^static int tty_disc = N_TTY;	\/* The TTY discipline *\/$/;"	v	file:
tty_disestablish_ppp	sys-linux.c	/^void tty_disestablish_ppp(int tty_fd)$/;"	f
tty_disestablish_ppp	sys-solaris.c	/^tty_disestablish_ppp(fd)$/;"	f
tty_disestablish_ppp	sys-sunos4.c	/^tty_disestablish_ppp(fd)$/;"	f
tty_do_send_config	tty.c	/^tty_do_send_config(mtu, accm, pcomp, accomp)$/;"	f
tty_establish_ppp	sys-linux.c	/^int tty_establish_ppp (int tty_fd)$/;"	f
tty_establish_ppp	sys-solaris.c	/^tty_establish_ppp(fd)$/;"	f
tty_establish_ppp	sys-sunos4.c	/^tty_establish_ppp(fd)$/;"	f
tty_init	tty.c	/^void tty_init()$/;"	f
tty_mode	tty.c	/^mode_t tty_mode = (mode_t)-1;	\/* Original access permissions to tty *\/$/;"	v
tty_modules	sys-solaris.c	/^static char	tty_modules[NMODULES][FMNAMESZ+1];$/;"	v	file:
tty_modules	sys-sunos4.c	/^static char	tty_modules[NMODULES][FMNAMESZ+1];$/;"	v	file:
tty_nmodules	sys-solaris.c	/^static int	tty_nmodules;$/;"	v	file:
tty_nmodules	sys-sunos4.c	/^static int	tty_nmodules;$/;"	v	file:
tty_npushed	sys-solaris.c	/^static int	tty_npushed;$/;"	v	file:
tty_options	tty.c	/^option_t tty_options[] = {$/;"	v
tty_process_extra_options	tty.c	/^void tty_process_extra_options()$/;"	f
tty_recv_config	sys-linux.c	/^void tty_recv_config (int mru,u_int32_t asyncmap,int pcomp,int accomp)$/;"	f
tty_recv_config	sys-solaris.c	/^tty_recv_config(mru, asyncmap, pcomp, accomp)$/;"	f
tty_send_config	sys-linux.c	/^void tty_send_config (int mtu,u_int32_t asyncmap,int pcomp,int accomp)$/;"	f
tty_send_config	sys-solaris.c	/^tty_send_config(mtu, asyncmap, pcomp, accomp)$/;"	f
tty_set_xaccm	sys-linux.c	/^void tty_set_xaccm (ext_accm accm)$/;"	f
tty_set_xaccm	sys-solaris.c	/^tty_set_xaccm(accm)$/;"	f
tty_sid	sys-solaris.c	/^static pid_t	tty_sid;	\/* original session ID for terminal *\/$/;"	v	file:
ttyfd	tty.c	/^static int ttyfd;		\/* Serial port file descriptor *\/$/;"	v	file:
tune_kernel	options.c	/^bool	tune_kernel;		\/* may alter kernel settings *\/$/;"	v
type	pppd.h	/^	enum opt_type type;$/;"	m	struct:
uafname	auth.c	/^static char *uafname;		\/* name of most recent +ua file *\/$/;"	v	file:
uid	main.c	/^uid_t uid;			\/* Our real user-id *\/$/;"	v
uid	main.old.c	/^uid_t uid;			\/* Our real user-id *\/$/;"	v
unit	chap.h	/^    int unit;			\/* Interface unit number *\/$/;"	m	struct:chap_state
unit	fsm.h	/^    int unit;			\/* Interface unit number *\/$/;"	m	struct:fsm
unlock	sys-solaris.c	/^unlock()$/;"	f
unlock	utils.c	/^unlock()$/;"	f
unsuccess	main.c	/^int unsuccess;			\/* # unsuccessful connection attempts *\/$/;"	v
unsuccess	main.old.c	/^int unsuccess;			\/* # unsuccessful connection attempts *\/$/;"	v
untimeout	main.c	/^untimeout(func, arg)$/;"	f
untimeout	main.old.c	/^untimeout(func, arg)$/;"	f
up	fsm.h	/^    void (*up)			\/* Called when fsm reaches OPENED state *\/$/;"	m	struct:fsm_callbacks
upap	upap.c	/^upap_state upap[NUM_PPP];		\/* UPAP state; one for each unit *\/$/;"	v
upap_authpeer	upap.c	/^upap_authpeer(unit)$/;"	f
upap_authwithpeer	upap.c	/^upap_authwithpeer(unit, user, password)$/;"	f
upap_codenames	upap.c	/^static char *upap_codenames[] = {$/;"	v	file:
upap_init	upap.c	/^upap_init(unit)$/;"	f	file:
upap_input	upap.c	/^upap_input(unit, inpacket, l)$/;"	f	file:
upap_lowerdown	upap.c	/^upap_lowerdown(unit)$/;"	f	file:
upap_lowerup	upap.c	/^upap_lowerup(unit)$/;"	f	file:
upap_printpkt	upap.c	/^upap_printpkt(p, plen, printer, arg)$/;"	f	file:
upap_protrej	upap.c	/^upap_protrej(unit)$/;"	f	file:
upap_rauthack	upap.c	/^upap_rauthack(u, inp, id, len)$/;"	f	file:
upap_rauthnak	upap.c	/^upap_rauthnak(u, inp, id, len)$/;"	f	file:
upap_rauthreq	upap.c	/^upap_rauthreq(u, inp, id, len)$/;"	f	file:
upap_reqtimeout	upap.c	/^upap_reqtimeout(arg)$/;"	f	file:
upap_sauthreq	upap.c	/^upap_sauthreq(u)$/;"	f	file:
upap_sresp	upap.c	/^upap_sresp(u, code, id, msg, msglen)$/;"	f	file:
upap_state	upap.h	/^typedef struct upap_state {$/;"	s
upap_state	upap.h	/^} upap_state;$/;"	t
upap_timeout	upap.c	/^upap_timeout(arg)$/;"	f	file:
update_db_entry	main.c	/^update_db_entry()$/;"	f	file:
update_db_entry	main.old.c	/^update_db_entry()$/;"	f	file:
update_link_stats	main.c	/^update_link_stats(u)$/;"	f
update_link_stats	main.old.c	/^update_link_stats(u)$/;"	f
updetach	options.c	/^bool	updetach = 0;		\/* Detach once link is up *\/$/;"	v
upper_limit	pppd.h	/^	int	upper_limit;$/;"	m	struct:
us_allowed	cbcp.h	/^    u_char us_allowed;$/;"	m	struct:cbcp_state
us_clientstate	upap.h	/^    int us_clientstate;		\/* Client state *\/$/;"	m	struct:upap_state
us_id	cbcp.h	/^    u_char us_id;		\/* Current id *\/$/;"	m	struct:cbcp_state
us_id	upap.h	/^    u_char us_id;		\/* Current id *\/$/;"	m	struct:upap_state
us_maxtransmits	upap.h	/^    int us_maxtransmits;	\/* Maximum number of auth-reqs to send *\/$/;"	m	struct:upap_state
us_number	cbcp.h	/^    char   *us_number;    \/* Telefone Number *\/$/;"	m	struct:cbcp_state
us_passwd	upap.h	/^    char *us_passwd;		\/* Password *\/$/;"	m	struct:upap_state
us_passwdlen	upap.h	/^    int us_passwdlen;		\/* Password length *\/$/;"	m	struct:upap_state
us_reqtimeout	upap.h	/^    int us_reqtimeout;		\/* Time to wait for auth-req from peer *\/$/;"	m	struct:upap_state
us_serverstate	upap.h	/^    int us_serverstate;		\/* Server state *\/$/;"	m	struct:upap_state
us_timeouttime	upap.h	/^    int us_timeouttime;		\/* Timeout (seconds) for auth-req retrans. *\/$/;"	m	struct:upap_state
us_transmits	upap.h	/^    int us_transmits;		\/* Number of auth-reqs sent *\/$/;"	m	struct:upap_state
us_type	cbcp.h	/^    int    us_type;$/;"	m	struct:cbcp_state
us_unit	cbcp.h	/^    int    us_unit;	\/* Interface unit number *\/$/;"	m	struct:cbcp_state
us_unit	upap.h	/^    int us_unit;		\/* Interface unit number *\/$/;"	m	struct:upap_state
us_user	upap.h	/^    char *us_user;		\/* User *\/$/;"	m	struct:upap_state
us_userlen	upap.h	/^    int us_userlen;		\/* User length *\/$/;"	m	struct:upap_state
usage	options.c	/^usage()$/;"	f	file:
usage_string	options.c	/^static char *usage_string = "\\$/;"	v	file:
use_ip	ipv6cp.h	/^    int use_ip;			\/* use IP as interface identifier *\/$/;"	m	struct:ipv6cp_options
use_persistent	ipv6cp.h	/^    int use_persistent;		\/* use uniquely persistent value for address *\/$/;"	m	struct:ipv6cp_options
used_login	auth.c	/^static int used_login;		\/* peer authenticated against login database *\/$/;"	v	file:
usehostname	auth.c	/^bool usehostname = 0;		\/* Use hostname for our_name *\/$/;"	v
uselogin	auth.c	/^bool uselogin = 0;		\/* Use \/etc\/passwd for checking PAP *\/$/;"	v
usepeerdns	ipcp.c	/^static bool usepeerdns;			\/* Ask peer for DNS addrs *\/$/;"	v	file:
user	options.c	/^char	user[MAXNAMELEN];	\/* Username for PAP *\/$/;"	v
using_pty	tty.c	/^int	using_pty = 0;		\/* we're allocating a pty as the device *\/$/;"	v
utsname	sys-linux.c	/^static struct utsname utsname;	\/* for the kernel version *\/$/;"	v	file:
value	options.c	/^    char value[1];$/;"	m	struct:option_value	file:
value	pppd.h	/^    unsigned char	value[MAX_ENDP_LEN];$/;"	m	struct:epdisc
version	tdb.h	/^	unsigned version; \/* version of the code *\/$/;"	m	struct:tdb_header
vj_protocol	ipcp.h	/^    int  vj_protocol;		\/* protocol value to use in VJ option *\/$/;"	m	struct:ipcp_options
vj_protocol	ipv6cp.h	/^    u_short vj_protocol;	\/* protocol value to use in VJ option *\/$/;"	m	struct:ipv6cp_options
vj_value	ipcp.c	/^static char vj_value[8];		\/* string form of vj option value *\/$/;"	v	file:
volatile	pppd.h	44;"	d
vslp_printer	utils.c	/^vslp_printer __V((void *arg, char *fmt, ...))$/;"	f	file:
vslprintf	utils.c	/^vslprintf(buf, buflen, fmt, args)$/;"	f
wait_input	sys-linux.c	/^void wait_input(struct timeval *timo)$/;"	f
wait_input	sys-solaris.c	/^wait_input(timo)$/;"	f
wait_input	sys-sunos4.c	/^wait_input(timo)$/;"	f
waiting	main.c	/^static int waiting;$/;"	v	file:
waiting	main.old.c	/^static int waiting;$/;"	v	file:
warn	utils.c	/^warn __V((char *fmt, ...))$/;"	f
welcomer	tty.c	/^char	*welcomer = NULL;	\/* Script to run after phys link estab. *\/$/;"	v
winner	pppd.h	/^	short int winner;$/;"	m	struct:
winsaddr	ipcp.h	/^    u_int32_t winsaddr[2];	\/* Primary and secondary MS WINS entries *\/$/;"	m	struct:ipcp_options
wo	ipxcp.c	50;"	d	file:
word	pppd.h	/^    char		*word;$/;"	m	struct:wordlist
wordlist	pppd.h	/^struct wordlist {$/;"	s
wordlist_count	auth.c	/^wordlist_count(wp)$/;"	f	file:
wsinfo	sys-solaris.c	/^static struct winsize wsinfo;	\/* Initial window size info *\/$/;"	v	file:
wsinfo	sys-sunos4.c	/^static struct winsize wsinfo;	\/* Initial window size info *\/$/;"	v	file:
xmit_accm	tty.c	/^u_int32_t xmit_accm[8];		\/* extended transmit ACCM *\/$/;"	v
zero_node	ipxcp.c	/^zero_node (node)$/;"	f	file:
